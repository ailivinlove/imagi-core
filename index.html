<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #numTrialsSlider {
            width: 100%;
            margin-top: 8px;
        }

        #numTrialsDisplay {
            display: block;
            margin-top: 8px;
            font-weight: 600;
            color: #e94560;
        }

        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .hint {
            display: block;
            margin-top: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        #btnInstructions.completed::after {
            content: ' ✓';
            font-weight: 700;
            color: #2ecc71;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }

        #dlgInstructions {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.88);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 999;
        }

        #dlgInstructions[hidden] {
            display: none;
        }

        #dlgInstructions > header,
        #dlgInstructions > footer,
        #dlgInstructions > nav,
        #dlgInstructions > article {
            width: min(960px, 100%);
        }

        #dlgInstructions > header {
            background: #16213e;
            padding: 20px 60px 20px 24px;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        #instTitle {
            margin-bottom: 12px;
            font-size: 1.6rem;
        }

        #instClose {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 1.4rem;
            line-height: 1;
            color: #e94560;
            cursor: pointer;
            padding: 4px 8px;
        }

        #instClose:hover {
            transform: none;
            color: #fff;
            background: transparent;
            box-shadow: none;
        }

        #instTabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            background: #0f3460;
            padding: 16px;
        }

        #instTabs button {
            background: #16213e;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.95rem;
            border: 1px solid transparent;
        }

        #instTabs button.active {
            background: #e94560;
            border-color: #f08fa2;
        }

        #instTabs button.visited:not(.active) {
            border-color: #27ae60;
        }

        #instContent {
            background: #0a0e1a;
            padding: 24px;
            min-height: 280px;
            max-height: 360px;
            overflow-y: auto;
            outline: none;
        }

        #instContent h3 {
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        #instContent p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #walkthroughN2 .algo li {
            margin: 0.25rem 0;
        }

        #walkthroughN2 .anchors,
        #walkthroughN2 .returns {
            margin-left: 1rem;
        }

        #walkthroughN2 .trials > li {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border: 1px solid var(--border, #444);
            border-radius: 0.5rem;
            background: rgba(22, 33, 62, 0.6);
        }

        #walkthroughN2 .match {
            color: var(--ok, #2ecc71);
            font-weight: 600;
        }

        #walkthroughN2 .nomatch {
            color: var(--warn, #e67e22);
            font-weight: 600;
        }

        #walkthroughN2 .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        #walkthroughN2 .brandline {
            margin-bottom: 0.5rem;
        }

        #instContent ul,
        #instContent ol {
            margin-left: 20px;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #examplesFilters {
            margin: .5rem 0 1rem;
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        #examplesFilters button.active {
            font-weight: 700;
            text-decoration: underline;
        }

        #examplesList > li {
            margin: 0 0 1rem 0;
            padding: .75rem;
            border: 1px solid var(--border, #ddd);
            border-radius: .5rem;
        }

        .exActions {
            display: flex;
            gap: .5rem;
            margin-top: .5rem;
        }

        #instFooter {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #16213e;
            padding: 16px 24px;
            border-radius: 0 0 12px 12px;
        }

        #instFooter .inline {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        #instFooter .spacer {
            flex: 1;
        }

        .inst-brand-tagline {
            font-size: 0.9rem;
            color: #f5c0d1;
            line-height: 1.5;
        }

        body.dialog-open {
            overflow: hidden;
        }

        .sandbox-panel {
            margin-top: 16px;
            padding: 16px;
            background: #111a33;
            border-radius: 8px;
        }

        .sandbox-panel h4 {
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .sandbox-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter {
            background: #16213e;
            padding: 10px;
            border-radius: 6px;
        }

        .sandbox-letter label {
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .sandbox-letter input[type="text"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #1a4d7a;
            background: #0f3460;
            color: #fff;
        }

        .sandbox-atom-list {
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
        }

        .sandbox-journal {
            margin-top: 12px;
            max-height: 140px;
            overflow-y: auto;
            background: #0f0f24;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .sandbox-journal-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(233, 69, 96, 0.4);
        }

        @media (max-width: 780px) {
            #instTabs {
                grid-template-columns: repeat(2, 1fr);
            }

            #instFooter {
                flex-direction: column;
                align-items: stretch;
            }

            #instFooter .spacer {
                display: none;
            }

            .inst-footer-brand {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <h1>🌀Imagi-world🌀</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">1</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="1">
            </div>

            <div class="control-group">
                <label>Atoms per Premise (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">8.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="2" max="20" step="0.5" value="8.0">
                    <input type="number" id="spt-number" min="2" max="20" step="0.5" value="8.0">
                </div>
            </div>

            <div class="control-group">
                <label for="numTrialsInput">Number of trials per session</label>
                <input id="numTrialsInput" type="number" min="1" max="10000" step="1" value="20" />
                <input id="numTrialsSlider" type="range" min="1" max="500" step="1" value="20" />
                <span id="numTrialsDisplay">Trials: 20</span>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="transitivity-toggle">
                <label for="transitivity-toggle" style="margin-bottom: 0;">Enable Advanced Transitivity</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div class="control-group">
                <label class="inline" title="Let the session play without responses">
                    <input id="listenOnlyToggle" type="checkbox" />
                    Listen-Only (Auto-Advance)
                </label>
                <small id="listenOnlyHint" aria-live="polite" hidden>
                    Listening mode: scoring disabled; session will auto-advance to completion.
                </small>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                    <button id="btnInstructions" aria-haspopup="dialog" aria-controls="dlgInstructions">Instructions</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Download so far</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>

        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </main>

    <section id="dlgInstructions" role="dialog" aria-modal="true" aria-labelledby="instTitle" hidden>
        <header>
            <h2 id="instTitle">Imagi-World: Learn the Arc of Abstraction</h2>
            <p class="inst-brand-tagline"><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought—your route to deeper consciousness.</p>
            <button id="instClose" aria-label="Close">✕</button>
        </header>

        <nav id="instTabs" aria-label="Tutorial Sections">
            <button data-tab="welcome" class="active">Welcome</button>
            <button data-tab="compass">Imagi-Compass</button>
            <button data-tab="anchor">Anchor &amp; Transform</button>
            <button data-tab="examples">Guided Examples</button>
            <button data-tab="practice">Sandbox Practice</button>
            <button data-tab="mastery">Mastery Path</button>
            <button data-tab="pitfalls">Pitfalls &amp; FAQ</button>
            <button data-tab="glossary">Glossary</button>
        </nav>

        <article id="instContent" tabindex="0" aria-live="polite"></article>

        <footer id="instFooter">
            <label class="inline">
                <input id="instReadAloud" type="checkbox" />
                Read this section aloud
            </label>
            <div class="spacer"></div>
            <button id="instPrev">← Previous</button>
            <button id="instNext">Next →</button>
        </footer>
    </section>

    <script type="module">
        const RELATION_WORDS = { N: 'north of', S: 'south of', E: 'east of', W: 'west of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];
        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;
        const conflictConfig = {
            foilRate: 0.35,
            foilTypesWeights: {
                ANCHOR_ONE: 0.20,
                PAIR_SWAP: 0.20,
                PARITY_OFF: 0.15,
                AXIS_ORTHO: 0.15,
                DERIVED_IN_ONE: 0.15,
                WINDOW_SHADOW: 0.15
            }
        };

        const NUM_TRIALS_KEY = 'numTrials';
        const LISTEN_ONLY_KEY = 'listenOnly';
        const numTrialsInput = document.getElementById('numTrialsInput');
        const numTrialsSlider = document.getElementById('numTrialsSlider');
        const numTrialsDisplay = document.getElementById('numTrialsDisplay');
        const listenOnlyToggle = document.getElementById('listenOnlyToggle');
        const listenOnlyHint = document.getElementById('listenOnlyHint');

        function loadListenOnly() {
            try {
                return localStorage.getItem(LISTEN_ONLY_KEY) === '1';
            } catch (err) {
                console.warn('Failed to load listen-only preference', err);
                return false;
            }
        }

        function persistListenOnly(on) {
            try {
                localStorage.setItem(LISTEN_ONLY_KEY, on ? '1' : '0');
            } catch (err) {
                console.warn('Failed to persist listen-only preference', err);
            }
            if (listenOnlyHint) {
                listenOnlyHint.hidden = !on;
            }
        }

        if (listenOnlyToggle) {
            const initListenOnly = loadListenOnly();
            listenOnlyToggle.checked = initListenOnly;
            persistListenOnly(initListenOnly);
            listenOnlyToggle.addEventListener('change', () => {
                persistListenOnly(listenOnlyToggle.checked);
            });
        }

        const TUTORIAL_SECTIONS = [
            {
                id: 'welcome',
                title: 'Welcome to Imagi-World',
                html: `
                    <h3>Welcome to Imagi-World</h3>
                    <p><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought—your route to deeper consciousness.</p>
                    <p>Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the <strong>Arc of Abstraction</strong> using the <strong>Imagi-Compass</strong>. North means <strong>up-shift</strong> to higher-order concepts, South means <strong>down-shift</strong> to concrete instances, East means <strong>analogue</strong> (same role/sibling concept), West means <strong>opposite</strong> (counterpart/foil).</p>
                    <p>The spatial logic remains strict; your analogies ride on top. This union—formal clarity plus creative projection—is our brand and our method.</p>
                    <p><strong>Outcome:</strong> by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.</p>
                `,
                speech: 'Welcome to Imagi-World. Imagi-World trains maximized imagination across the Arc of Abstraction. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought—your route to deeper consciousness. Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the Arc of Abstraction using the Imagi-Compass. North means up-shift to higher-order concepts. South means down-shift to concrete instances. East means analogue, the same role or a sibling concept. West means opposite, the counterpart or foil. The spatial logic remains strict, and your analogies ride on top. This union, formal clarity plus creative projection, is our brand and our method. Outcome: by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.'
            },
            {
                id: 'compass',
                title: 'The Imagi-Compass',
                html: `
                    <h3>The Imagi-Compass</h3>
                    <ul>
                        <li><strong>North (↑ Up-shift):</strong> move to meta, greater scale, more general, more intense. “Candle → Fireworks”; “Task → Project → Program.”</li>
                        <li><strong>South (↓ Down-shift):</strong> move to instance, component, concrete, less intense. “Theory → Example”; “System → Tool → Part.”</li>
                        <li><strong>East (→ Analogue):</strong> parallel function or sibling concept. “Candle → Lantern”; “Fact → Case study”; “Parent → Guardian.”</li>
                        <li><strong>West (← Opposite):</strong> antonym/counter-role. “Fact ↔ Fiction”; “Order ↔ Chaos”; “Light ↔ Darkness.”</li>
                    </ul>
                    <p><strong>Rule:</strong> your analogical mapping must be <strong>self-consistent</strong> within a session. Reframes are allowed but must be acknowledged.</p>
                `,
                speech: 'The Imagi-Compass. North, the up-shift, moves to meta, to greater scale, to more general or more intense territory. Candle to fireworks. Task to project to program. South, the down-shift, moves to instance, to component, to concrete or less intense forms. Theory to example. System to tool to part. East, the analogue, is the parallel function or sibling concept. Candle to lantern. Fact to case study. Parent to guardian. West, the opposite, is the antonym or counter-role. Fact to fiction. Order to chaos. Light to darkness. Rule: your analogical mapping must be self-consistent within a session. Reframes are allowed but must be acknowledged.'
            },
            {
                id: 'anchor',
                title: 'Step-by-Step: Anchor & Transform',
                html: `
                    <h3>Step-by-Step: Anchor &amp; Transform</h3>
                    <ol>
                        <li><strong>Anchor</strong> one letter from the current premise to a real concept from your stream of consciousness (write it or think it). Example: <code>X := “Fact”</code>.</li>
                        <li><strong>Transform</strong> per atom:
                            <ul>
                                <li><code>Y is north of X</code> → <code>Y := Up-shift(X)</code> → “Theory”.</li>
                                <li><code>Z is west of X</code> → <code>Z := Opposite(X)</code> → “Fiction”.</li>
                                <li><code>R is south of Y</code> → <code>R := Down-shift(Y)</code> → “Example”.</li>
                                <li><code>H is east of R</code> → <code>H := Analogue(R)</code> → “Case study”.</li>
                            </ul>
                        </li>
                        <li><strong>Check coherence</strong>: does each transformed concept match its relational cue? If yes, commit this mapping to your session notes.</li>
                        <li><strong>Never bleed analogies into scoring</strong>: logic is graded by the formal engine; analogies are your training mirror.</li>
                    </ol>
                    <p><strong>Mantra:</strong> <strong>Anchor → Transform → Cohere → Commit.</strong></p>
                `,
                speech: 'Step-by-Step: Anchor and Transform. One: Anchor one letter from the current premise to a real concept from your stream of consciousness, write it or think it. Example: X equals Fact. Two: Transform per atom. Y is north of X, so Y equals the up-shift of X, Theory. Z is west of X, so Z equals the opposite of X, Fiction. R is south of Y, so R equals the down-shift of Y, Example. H is east of R, so H equals the analogue of R, Case study. Three: Check coherence. Does each transformed concept match its relational cue? If yes, commit this mapping to your session notes. Four: Never bleed analogies into scoring. Logic is graded by the formal engine; analogies are your training mirror. Mantra: Anchor, Transform, Cohere, Commit.'
            },
            {
                id: 'examples',
                title: 'Guided Examples',
                html: `
                    <h3>Guided Examples</h3>
                    <p>The worked library loads in a moment. Use it to study beginner-friendly mappings across every compass move.</p>
                `,
                speech: 'Guided Examples. Explore the library of thirty worked analogies. Use the filter buttons to focus on single atoms, dual heads, chains, or full quartets. Each entry shows the premise, anchors, compass moves, the resulting mapping, and a quick rationale. Tap Speak summary to hear one in the same training voice.'
            },
            {
                id: 'practice',
                title: 'Sandbox Practice (Not Scored)',
                html: `
                    <h3>Sandbox Practice (Not Scored)</h3>
                    <ul>
                        <li>This is a safe studio. Load the <strong>latest premise</strong> (button “Load current premise”), or spawn a <strong>fresh training premise</strong> (button “Spawn practice premise”).</li>
                        <li>Enter concepts for the letters; click <strong>Apply Relation Operations</strong> to auto-suggest analogues/opposites/up/down (you may override).</li>
                        <li>Use <strong>Commit to Journal</strong> to save your mapping snapshots (they do not affect your game score).</li>
                        <li>Toggle <strong>Read this section aloud</strong> for gentle narration using the same single voice the game uses.</li>
                    </ul>
                    <p><strong>Tip:</strong> strive for <strong>one-sentence explanations</strong> that justify your choices: “I chose <em>Theory</em> above <em>Fact</em> because it generalizes observations into predictive structure.”</p>
                `,
                speech: 'Sandbox Practice, not scored. This is a safe studio. Load the latest premise with the button Load current premise, or spawn a fresh training premise with the button Spawn practice premise. Enter concepts for the letters; click Apply Relation Operations to auto-suggest analogues, opposites, up, or down shifts. You may override anything. Use Commit to Journal to save your mapping snapshots. They do not affect your game score. Toggle Read this section aloud for gentle narration using the same single voice the game uses. Tip: strive for one-sentence explanations that justify your choices, such as, I chose Theory above Fact because it generalizes observations into predictive structure.'
            },
            {
                id: 'mastery',
                title: 'Mastery: From Symbols to Schemas',
                html: `
                    <h3>Mastery: From Symbols to Schemas</h3>
                    <ul>
                        <li><strong>Level 1 — Single-atom fluency:</strong> 95% accuracy in naming valid up/down/analogue/opposite for any anchor within 3 seconds.</li>
                        <li><strong>Level 2 — Two-atom coordination:</strong> keep consistency when a letter appears in two relations; reconcile tensions by compound mappings (“chaotic example”).</li>
                        <li><strong>Level 3 — Chain reasoning:</strong> three or more atoms spanning two axes; maintain semantic integrity across the chain.</li>
                        <li><strong>Level 4 — Near-miss foils:</strong> detect when premises <strong>look</strong> similar but fail one criterion (anchoring parity, mapping, axis alignment, derivability). Explain <strong>why</strong> they’re not matches in plain language.</li>
                        <li><strong>Level 5 — Transfer:</strong> take a mapping that worked in one theme (“Learning &amp; Illumination”) and remake it in a different theme (“Teams &amp; Leadership”), preserving relational roles: <code>Fact→Novice Task</code>, <code>Theory→Best Practice</code>, <code>Example→Case Review</code>, <code>Case study→Playbook</code>, <code>Fiction→Myth/Misconception</code>.</li>
                    </ul>
                    <p><strong>Mastery litmus:</strong> you can improvise <strong>new, coherent mappings</strong> at speed, across themes, while the logic engine remains satisfied—no contradictions, no shortcuts.</p>
                `,
                speech: 'Mastery: From Symbols to Schemas. Level one, single-atom fluency: ninety-five percent accuracy in naming valid up, down, analogue, or opposite moves for any anchor within three seconds. Level two, two-atom coordination: keep consistency when a letter appears in two relations; reconcile tensions by compound mappings such as Chaotic example. Level three, chain reasoning: three or more atoms spanning two axes; maintain semantic integrity across the chain. Level four, near-miss foils: detect when premises look similar but fail one criterion—anchoring parity, mapping, axis alignment, derivability. Explain why they are not matches in plain language. Level five, transfer: take a mapping that worked in one theme, Learning and Illumination, and remake it in a different theme, Teams and Leadership, preserving relational roles: Fact to Novice Task, Theory to Best Practice, Example to Case Review, Case study to Playbook, Fiction to Myth or Misconception. Mastery litmus: you can improvise new, coherent mappings at speed, across themes, while the logic engine remains satisfied—no contradictions, no shortcuts.'
            },
            {
                id: 'pitfalls',
                title: 'Pitfalls & FAQ',
                html: `
                    <h3>Pitfalls &amp; FAQ</h3>
                    <dl>
                        <dt><strong>Q:</strong> Can I use the same word for East (analogue)?</dt>
                        <dd><strong>A:</strong> Prefer <strong>siblings</strong>, not duplicates. “Candle → Lantern,” not “Candle → Candle.”</dd>
                        <dt><strong>Q:</strong> My West choice feels too cartoonish.</dt>
                        <dd><strong>A:</strong> “Opposite” includes <strong>counter-role</strong> or <strong>antagonist</strong>, not just antonym. “Order ↔ Chaos,” “Plan ↔ Improvisation.”</dd>
                        <dt><strong>Q:</strong> What if my mapping breaks later?</dt>
                        <dd><strong>A:</strong> Use a <strong>Reframe</strong> action. Log it. Consistency matters more than stubbornness.</dd>
                        <dt><strong>Q:</strong> Do analogies change scoring?</dt>
                        <dd><strong>A:</strong> No. Scoring is formal. Analogies train your <strong>semantic agility</strong>.</dd>
                    </dl>
                `,
                speech: 'Pitfalls and FAQ. Question: Can I use the same word for East, the analogue? Answer: Prefer siblings, not duplicates. Candle to Lantern, not Candle to Candle. Question: My West choice feels too cartoonish. Answer: Opposite includes counter-role or antagonist, not just antonym. Order to Chaos. Plan to Improvisation. Question: What if my mapping breaks later? Answer: Use a Reframe action. Log it. Consistency matters more than stubbornness. Question: Do analogies change scoring? Answer: No. Scoring is formal. Analogies train your semantic agility.'
            },
            {
                id: 'glossary',
                title: 'Glossary',
                html: `
                    <h3>Glossary</h3>
                    <ul>
                        <li><strong>Arc of Abstraction:</strong> the mental continuum from concrete/particular to abstract/general.</li>
                        <li><strong>Up-shift / Down-shift:</strong> moves along the Arc (North/South).</li>
                        <li><strong>Analogue / Opposite:</strong> lateral moves preserving or inverting role (East/West).</li>
                        <li><strong>Anchor:</strong> your chosen seed concept for a letter.</li>
                        <li><strong>Compound mapping:</strong> a single letter carrying a composed phrase to satisfy multiple relations (e.g., “chaotic example”).</li>
                    <li><strong>Reframe:</strong> deliberate change to an anchored concept, logged for consistency tracking.</li>
                </ul>
            `,
                speech: 'Glossary. Arc of Abstraction: the mental continuum from concrete or particular to abstract or general. Up-shift and Down-shift: moves along the arc, north and south. Analogue and Opposite: lateral moves preserving or inverting role, east and west. Anchor: your chosen seed concept for a letter. Compound mapping: a single letter carrying a composed phrase to satisfy multiple relations, for example Chaotic example. Reframe: deliberate change to an anchored concept, logged for consistency tracking.'
            },
            {
                id: 'walkthrough-n2-10',
                title: 'n-Back-2: 10-Trial Walkthrough',
                html: '',
                render: (mount) => renderWalkthroughN2(mount),
                speech: walkthroughN2SpeechText()
            }
        ];

        let guidedExamplesRoot = null;

        function renderGuidedExamples() {
            const mount = document.getElementById('instContent');
            if (!mount) return;

            if (guidedExamplesRoot && mount.dataset.examplesLoaded === '1') {
                mount.innerHTML = '';
                mount.appendChild(guidedExamplesRoot);
                return;
            }

            const examples = getBeginnerExamples();
            const container = document.createElement('div');
            container.id = 'guidedExamples';

            const heading = document.createElement('h3');
            heading.textContent = 'Guided Examples';
            container.appendChild(heading);

            const intro = document.createElement('p');
            intro.textContent = 'Study thirty beginner-friendly mappings. Anchor each letter, follow the compass moves, and confirm the resulting mapping with the provided rationale.';
            container.appendChild(intro);

            const filters = document.createElement('div');
            filters.id = 'examplesFilters';
            filters.innerHTML = `
                <strong>Filter:</strong>
                <button data-f="all" class="active">All</button>
                <button data-f="single">Single-atom</button>
                <button data-f="double-same-head">Two-atom (same head)</button>
                <button data-f="double-dual-head">Two-atom (dual heads)</button>
                <button data-f="triple-chain">Three-atom chains</button>
                <button data-f="quad">Four-atom sets</button>
            `;
            container.appendChild(filters);

            const list = document.createElement('ol');
            list.id = 'examplesList';
            container.appendChild(list);

            function renderList(filter = 'all') {
                list.innerHTML = '';
                examples
                    .filter(ex => filter === 'all' ? true : ex.level === filter)
                    .forEach(ex => {
                        const li = document.createElement('li');
                        li.className = `ex ex-${ex.level}`;
                        li.innerHTML = `
                            <h4>Ex ${ex.id}. ${ex.theme}</h4>
                            <p><strong>Premise:</strong> ${ex.premise}</p>
                            <p><strong>Anchors:</strong> ${ex.anchors.map(([L, c]) => `${L} := “${c}”`).join('; ')}</p>
                            <p><strong>Transforms:</strong> ${ex.transforms.join(' • ')}</p>
                            <p><strong>Resulting mapping:</strong> ${ex.mapping.map(([L, c]) => `${L} → “${c}”`).join('; ')}</p>
                            <p><em>Why it works:</em> ${ex.rationale}</p>
                            <div class="exActions">
                                <button data-speak="${ex.id}">Speak summary</button>
                                <button data-copy="${ex.id}">Copy to clipboard</button>
                            </div>
                        `;
                        list.appendChild(li);
                    });
            }

            renderList('all');

            container.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;
                const filter = button.dataset.f;
                if (filter) {
                    container.querySelectorAll('#examplesFilters button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderList(filter);
                    return;
                }
                if (button.dataset.speak) {
                    const id = parseInt(button.dataset.speak, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        speakOnce(summarizeExample(example));
                    }
                }
                if (button.dataset.copy) {
                    const id = parseInt(button.dataset.copy, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        const summary = summarizeExample(example);
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            navigator.clipboard.writeText(summary).catch(() => {
                                window.prompt('Copy this example summary:', summary);
                            });
                        } else {
                            window.prompt('Copy this example summary:', summary);
                        }
                    }
                }
            });

            function summarizeExample(ex) {
                const line1 = `Premise: ${ex.premise}`;
                const line2 = `Anchors: ${ex.anchors.map(([L, c]) => `${L} equals ${c}`).join('; ')}.`;
                const line3 = `Mapping: ${ex.mapping.map(([L, c]) => `${L} to ${c}`).join('; ')}.`;
                return `${line1} ${line2} ${line3}`;
            }

            mount.innerHTML = '';
            mount.appendChild(container);
            mount.dataset.examplesLoaded = '1';
            guidedExamplesRoot = container;
        }

        function getBeginnerExamples() {
            return [
                // --- Single-atom (10) ---
                { id:1, level:"single", theme:"Learning — Up-shift",
                  premise:"N is north of J.",
                  anchors:[["J","Fact"]],
                  transforms:["North(J→N): up-shift Fact → Theory"],
                  mapping:[["J","Fact"],["N","Theory"]],
                  rationale:"North is higher abstraction; Theory stands above Fact."
                },
                { id:2, level:"single", theme:"Biology — Down-shift",
                  premise:"B is south of A.",
                  anchors:[["A","Animal"]],
                  transforms:["South(A→B): down-shift Animal → Dog"],
                  mapping:[["A","Animal"],["B","Dog"]],
                  rationale:"South is more specific; Dog is an instance of Animal."
                },
                { id:3, level:"single", theme:"Illumination — Analogue",
                  premise:"C is east of D.",
                  anchors:[["D","Candle"]],
                  transforms:["East(D→C): analogue of Candle → Lantern"],
                  mapping:[["D","Candle"],["C","Lantern"]],
                  rationale:"East is same-role/sibling; Lantern parallels Candle."
                },
                { id:4, level:"single", theme:"Order/Chaos — Opposite",
                  premise:"E is west of F.",
                  anchors:[["F","Order"]],
                  transforms:["West(F→E): opposite of Order → Chaos"],
                  mapping:[["F","Order"],["E","Chaos"]],
                  rationale:"West is counterpart; Chaos opposes Order."
                },
                { id:5, level:"single", theme:"Technology — Up-shift",
                  premise:"G is north of H.",
                  anchors:[["H","Program"]],
                  transforms:["North(H→G): Program → Platform"],
                  mapping:[["H","Program"],["G","Platform"]],
                  rationale:"Platform generalizes programs; higher on the Arc."
                },
                { id:6, level:"single", theme:"Music — Down-shift",
                  premise:"I is south of K.",
                  anchors:[["K","Song"]],
                  transforms:["South(K→I): Song → Verse"],
                  mapping:[["K","Song"],["I","Verse"]],
                  rationale:"Verse is a component of a Song."
                },
                { id:7, level:"single", theme:"Navigation — Analogue",
                  premise:"L is east of M.",
                  anchors:[["M","Map"]],
                  transforms:["East(M→L): Map → Chart"],
                  mapping:[["M","Map"],["L","Chart"]],
                  rationale:"Chart is a sibling format to Map."
                },
                { id:8, level:"single", theme:"Emotion — Opposite",
                  premise:"P is west of O.",
                  anchors:[["O","Calm"]],
                  transforms:["West(O→P): Calm → Agitation"],
                  mapping:[["O","Calm"],["P","Agitation"]],
                  rationale:"Agitation is the counter-state of Calm."
                },
                { id:9, level:"single", theme:"Finance — Up-shift",
                  premise:"Q is north of R.",
                  anchors:[["R","Expense"]],
                  transforms:["North(R→Q): Expense → Budget"],
                  mapping:[["R","Expense"],["Q","Budget"]],
                  rationale:"Budget organizes expenses; higher level."
                },
                { id:10, level:"single", theme:"Astronomy — Down-shift",
                  premise:"T is south of S.",
                  anchors:[["S","Galaxy"]],
                  transforms:["South(S→T): Galaxy → Star"],
                  mapping:[["S","Galaxy"],["T","Star"]],
                  rationale:"A Star is a constituent of a Galaxy."
                },

                // --- Two-atom: same head (8) ---
                { id:11, level:"double-same-head", theme:"Theory & Order — Compound",
                  premise:"Z is south of J; Z is west of P.",
                  anchors:[["J","Theory"],["P","Order"]],
                  transforms:["South(J→Z): Theory → Example","West(P→Z): Order → Chaos (compound: Chaotic example)"],
                  mapping:[["J","Theory"],["P","Order"],["Z","Chaotic example"]],
                  rationale:"Z must satisfy both; a ‘Chaotic example’ fits down-shift and opposition."
                },
                { id:12, level:"double-same-head", theme:"Writing — Paragraph role",
                  premise:"A is north of B; A is east of C.",
                  anchors:[["B","Sentence"],["C","Section"]],
                  transforms:["North(B→A): Sentence → Paragraph","East(C→A): Section → Paragraph (sibling)"],
                  mapping:[["B","Sentence"],["C","Section"],["A","Paragraph"]],
                  rationale:"Paragraph stands above a Sentence and parallels a Section in function."
                },
                { id:13, level:"double-same-head", theme:"Physics — Heat vs Cold",
                  premise:"D is south of C; D is west of E.",
                  anchors:[["C","Energy"],["E","Cold"]],
                  transforms:["South(C→D): Energy → Heat","West(E→D): Cold → Heat"],
                  mapping:[["C","Energy"],["E","Cold"],["D","Heat"]],
                  rationale:"Heat is a specific form of Energy and the counter to Cold."
                },
                { id:14, level:"double-same-head", theme:"Light — Coherent mapping",
                  premise:"H is east of I; H is north of J.",
                  anchors:[["I","Lamp"],["J","Flame"]],
                  transforms:["East(I→H): Lamp → Lantern","North(J→H): Flame → Lantern (higher containment)"],
                  mapping:[["I","Lamp"],["J","Flame"],["H","Lantern"]],
                  rationale:"Lantern is a sibling of Lamp, and stands above Flame as container/assembly."
                },
                { id:15, level:"double-same-head", theme:"Ethics — Lying as behavior",
                  premise:"K is west of L; K is south of M.",
                  anchors:[["L","Truth"],["M","Behavior"]],
                  transforms:["West(L→K): Truth → Lie","South(M→K): Behavior → Lie"],
                  mapping:[["L","Truth"],["M","Behavior"],["K","Lie"]],
                  rationale:"A Lie opposes Truth and is a specific Behavior."
                },
                { id:16, level:"double-same-head", theme:"Literature — Forms",
                  premise:"N is east of O; N is south of P.",
                  anchors:[["O","Novel"],["P","Literature"]],
                  transforms:["East(O→N): Novel → Short story","South(P→N): Literature → Short story"],
                  mapping:[["O","Novel"],["P","Literature"],["N","Short story"]],
                  rationale:"Short story is a sibling to Novel and a specific of Literature."
                },
                { id:17, level:"double-same-head", theme:"Civics — Regulation vs Anarchy",
                  premise:"Q is north of R; Q is west of S.",
                  anchors:[["R","Procedure"],["S","Anarchy"]],
                  transforms:["North(R→Q): Procedure → Policy","West(S→Q): Anarchy → Policy"],
                  mapping:[["R","Procedure"],["S","Anarchy"],["Q","Policy"]],
                  rationale:"Policy sits above Procedure and opposes Anarchy’s absence of rules."
                },
                { id:18, level:"double-same-head", theme:"Roles — Medicine",
                  premise:"T is east of U; T is west of V.",
                  anchors:[["U","Doctor"],["V","Patient"]],
                  transforms:["East(U→T): Doctor → Physician","West(V→T): Patient → Physician (counter-role)"],
                  mapping:[["U","Doctor"],["V","Patient"],["T","Physician"]],
                  rationale:"Physician is a synonym/analogue of Doctor and the counter-role to Patient."
                },

                // --- Two-atom: dual heads (6) ---
                { id:19, level:"double-dual-head", theme:"Data & Tools",
                  premise:"W is north of X; Y is east of Z.",
                  anchors:[["X","Data"],["Z","Hammer"]],
                  transforms:["North(X→W): Data → Information","East(Z→Y): Hammer → Tool"],
                  mapping:[["X","Data"],["W","Information"],["Z","Hammer"],["Y","Tool"]],
                  rationale:"Information abstracts Data; Tool parallels Hammer."
                },
                { id:20, level:"double-dual-head", theme:"Order & Nature",
                  premise:"A is west of B; C is south of D.",
                  anchors:[["B","Order"],["D","Tree"]],
                  transforms:["West(B→A): Order → Chaos","South(D→C): Tree → Branch"],
                  mapping:[["B","Order"],["A","Chaos"],["D","Tree"],["C","Branch"]],
                  rationale:"Chaos opposes Order; Branch is part of Tree."
                },
                { id:21, level:"double-dual-head", theme:"Transport & Cities",
                  premise:"E is east of F; G is north of H.",
                  anchors:[["F","Ship"],["H","Town"]],
                  transforms:["East(F→E): Ship → Boat (sibling craft)","North(H→G): Town → City"],
                  mapping:[["F","Ship"],["E","Boat"],["H","Town"],["G","City"]],
                  rationale:"Boat parallels Ship; City stands above Town."
                },
                { id:22, level:"double-dual-head", theme:"Light & Art",
                  premise:"I is west of J; K is east of L.",
                  anchors:[["J","Light"],["L","Poem"]],
                  transforms:["West(J→I): Light → Darkness","East(L→K): Poem → Song (sibling artform)"],
                  mapping:[["J","Light"],["I","Darkness"],["L","Poem"],["K","Song"]],
                  rationale:"Darkness is the counter-state to Light; Song parallels Poem."
                },
                { id:23, level:"double-dual-head", theme:"Systems & Life",
                  premise:"M is south of N; O is west of P.",
                  anchors:[["N","System"],["P","Life"]],
                  transforms:["South(N→M): System → Module","West(P→O): Life → Death"],
                  mapping:[["N","System"],["M","Module"],["P","Life"],["O","Death"]],
                  rationale:"Module is a part of a System; Death opposes Life."
                },
                { id:24, level:"double-dual-head", theme:"Food & Geography",
                  premise:"Q is east of R; S is south of T.",
                  anchors:[["R","Breakfast"],["T","Continent"]],
                  transforms:["East(R→Q): Breakfast → Brunch (analogue)","South(T→S): Continent → Country"],
                  mapping:[["R","Breakfast"],["Q","Brunch"],["T","Continent"],["S","Country"]],
                  rationale:"Brunch parallels Breakfast; Country is within a Continent."
                },

                // --- Three-atom chains (4) ---
                { id:25, level:"triple-chain", theme:"Logic — Counterexample path",
                  premise:"A is south of B; C is east of A; D is west of C.",
                  anchors:[["B","Theory"]],
                  transforms:["South(B→A): Theory → Example","East(A→C): Example → Case study","West(C→D): Case study → Counterexample"],
                  mapping:[["B","Theory"],["A","Example"],["C","Case study"],["D","Counterexample"]],
                  rationale:"A down; C lateral sibling; D as foil to C—consistent chain."
                },
                { id:26, level:"triple-chain", theme:"Projects — Work breakdown",
                  premise:"E is north of F; G is south of E; H is east of G.",
                  anchors:[["F","Task"]],
                  transforms:["North(F→E): Task → Project","South(E→G): Project → Subtask","East(G→H): Subtask → Work item"],
                  mapping:[["F","Task"],["E","Project"],["G","Subtask"],["H","Work item"]],
                  rationale:"Up then down then sideways within the same work hierarchy."
                },
                { id:27, level:"triple-chain", theme:"Deception — Roles",
                  premise:"I is west of J; K is north of I; L is east of K.",
                  anchors:[["J","Truth"]],
                  transforms:["West(J→I): Truth → Lie","North(I→K): Lie → Deception strategy","East(K→L): Deception strategy → Ruse"],
                  mapping:[["J","Truth"],["I","Lie"],["K","Deception strategy"],["L","Ruse"]],
                  rationale:"Counter-role, then abstraction, then sibling tactic."
                },
                { id:28, level:"triple-chain", theme:"Design — Deliverables",
                  premise:"M is east of N; O is north of M; P is south of O.",
                  anchors:[["N","Sketch"]],
                  transforms:["East(N→M): Sketch → Outline","North(M→O): Outline → Design","South(O→P): Design → Wireframe"],
                  mapping:[["N","Sketch"],["M","Outline"],["O","Design"],["P","Wireframe"]],
                  rationale:"Analogue within drafting, then up to Design, then down to a specific artifact."
                },

                // --- Four-atom (2) ---
                { id:29, level:"quad", theme:"Learning — Full weave",
                  premise:"H is east of R; Y is north of X; R is south of Y; Z is west of X.",
                  anchors:[["X","Fact"]],
                  transforms:[
                    "North(X→Y): Fact → Theory",
                    "South(Y→R): Theory → Example",
                    "East(R→H): Example → Case study",
                    "West(X→Z): Fact → Fiction"
                  ],
                  mapping:[["X","Fact"],["Y","Theory"],["R","Example"],["H","Case study"],["Z","Fiction"]],
                  rationale:"Classic quartet: up from Fact, down to Example, lateral to Case study, counter to Fiction."
                },
                { id:30, level:"quad", theme:"Education — Pedagogy weave",
                  premise:"A is west of D; B is north of A; C is east of B; D is south of C.",
                  anchors:[["A","Play"],["B","Pedagogy"],["C","Andragogy"]],
                  transforms:[
                    "Given A=Play; West requires D to be its structured counterpart → Lesson",
                    "North(A→B): Play → Pedagogy (framework above)",
                    "East(B→C): Pedagogy → Andragogy (sibling adult-learning)",
                    "South(C→D): Andragogy → Lesson (specific instructional unit)"
                  ],
                  mapping:[["A","Play"],["B","Pedagogy"],["C","Andragogy"],["D","Lesson"]],
                  rationale:"Play vs Lesson as counter-styles; Pedagogy above Play; Andragogy as sibling to Pedagogy; Lesson as a concrete unit under Andragogy."
                }
            ];
        }

        function walkthroughN2SpeechText() {
            return [
                'n-back two, ten trial walkthrough.',
                'Algorithm reminder: symbol, map a thought, transform by the operation, pair letter and thought, repeat across atoms, recall and update prior pairings when letters return.',
                'Theme: illumination and understanding.',
                'Anchors: J equals Candle; D equals Fireworks; X equals Observation; Y equals Generalization; Z equals Anomaly.',
                'Trial one: D is north of J. Trial two: Z is west of X; Z is south of Y.',
                'Trial three: J is south of D. Match with trial one.',
                'Trial four: X is east of Z; Y is north of Z. Match with trial two.',
                'Trial five: D is east of J. No match with trial three.',
                'Trial six: Z is west of X; Z is south of Y. Match with trial four.',
                'Trial seven: J is west of D. Match with trial five.',
                'Trial eight: X is east of Z. No match with trial six.',
                'Trial nine: D is east of J. Match with trial seven.',
                'Trial ten: Z is west of X. Match with trial eight.',
                'When a letter returns, reuse its concept and update by the new relation; keep coherence across trials.'
            ].join(' ');
        }

        function renderWalkthroughN2(mount = document.getElementById('instContent')) {
            if (!mount) return;

            const html = `
            <div id="walkthroughN2" class="inst-section">
                <h3>n-Back-2: 10-Trial Walkthrough</h3>

                <p class="brandline"><strong>Imagi-World trains maximized imagination across the Arc of Abstraction.</strong> You map lived concepts onto letters and move them North/South/East/West while the logic engine keeps relations exact.</p>

                <h4>Quick Algorithm (repeat this every premise)</h4>
                <ol class="algo">
                    <li><strong>Symbol →</strong> Note the letter(s) in the current premise.</li>
                    <li><strong>Map a thought →</strong> Anchor each new letter to a vivid concept (your stream of consciousness).</li>
                    <li><strong>Transform →</strong> Apply the premise operation to that concept: North = up-shift (more general/intense); South = down-shift (more specific/concrete); East = analogue/sibling; West = opposite/counter-role.</li>
                    <li><strong>Pairing →</strong> Record the resulting <em>letter ↔ thought</em> pairing for this trial.</li>
                    <li><strong>Rinse/Repeat →</strong> For multi-atom premises, repeat for each relation in the utterance (semicolon = tiny pause).</li>
                    <li><strong>Recall & Update →</strong> When a letter reappears later, reuse its prior mapping and <em>update</em> it by the new relation (e.g., if K is north of J, then when P is above K you can infer new context linking P and J, too).</li>
                </ol>

                <h4>Theme for this walkthrough</h4>
                <p>We use a coherent theme: <em>Illumination &amp; Understanding</em>. First-time anchors:</p>
                <ul class="anchors">
                    <li>J := Candle (steady light)</li>
                    <li>D := Fireworks (intense/brief light)</li>
                    <li>X := Observation (raw sighting)</li>
                    <li>Y := Generalization (above observations)</li>
                    <li>Z := Anomaly (foil to a typical observation)</li>
                </ul>

                <h4>Ten Trials at n-Back-2 (MATCH means current ≡ trial t−2 under allowed inversions)</h4>

                <ol class="trials">
                    <li>
                        <p><strong>Trial 1 — Premise:</strong> D is north of J.</p>
                        <p><strong>Mapping:</strong> J=Candle; North → D=Fireworks (up-shift intensity).</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 2 — Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> X=Observation; Y=Generalization; West → Z=Anomaly (foil to typical observation); South from Y confirms Z is specific.</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 3 — Premise:</strong> J is south of D.</p>
                        <p><strong>Mapping:</strong> Reuse J=Candle, D=Fireworks; South means Candle is less intense than Fireworks.</p>
                        <p><strong>n-back-2 vs Trial 1:</strong> <span class="match">MATCH</span> (inverse: D north of J ↔ J south of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 4 — Premise:</strong> X is east of Z; Y is north of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Y, Z; East: Observation is a sibling to Anomaly; North: Generalization above Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 2:</strong> <span class="match">MATCH</span> (Z west of X ↔ X east of Z; Z south of Y ↔ Y north of Z).</p>
                    </li>
                    <li>
                        <p><strong>Trial 5 — Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; East: both are light sources (analogue). Optionally note D as “burst light”.</p>
                        <p><strong>n-back-2 vs Trial 3:</strong> <span class="nomatch">NO MATCH</span> (Trial 3 was South; axis mismatch, not an allowed inversion).</p>
                    </li>
                    <li>
                        <p><strong>Trial 6 — Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> Same structure as Trial 2; reuse without re-anchoring.</p>
                        <p><strong>n-back-2 vs Trial 4:</strong> <span class="match">MATCH</span> (inverse pair of atoms holds).</p>
                    </li>
                    <li>
                        <p><strong>Trial 7 — Premise:</strong> J is west of D.</p>
                        <p><strong>Mapping:</strong> Reuse J, D; West: Candle as counter to Fireworks (steady vs fleeting).</p>
                        <p><strong>n-back-2 vs Trial 5:</strong> <span class="match">MATCH</span> (D east of J ↔ J west of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 8 — Premise:</strong> X is east of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Z; East: Observation as sibling to Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 6:</strong> <span class="nomatch">NO MATCH</span> (parity mismatch: k=1 vs k=2).</p>
                    </li>
                    <li>
                        <p><strong>Trial 9 — Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; analogue relation sustained.</p>
                        <p><strong>n-back-2 vs Trial 7:</strong> <span class="match">MATCH</span> (inverse of Trial 7).</p>
                    </li>
                    <li>
                        <p><strong>Trial 10 — Premise:</strong> Z is west of X.</p>
                        <p><strong>Mapping:</strong> Reuse Z, X; West: Anomaly as foil to Observation.</p>
                        <p><strong>n-back-2 vs Trial 8:</strong> <span class="match">MATCH</span> (inverse of Trial 8).</p>
                    </li>
                </ol>

                <h4>When the same letter returns: do this</h4>
                <ul class="returns">
                    <li><strong>Reuse</strong> the original concept; don’t re-anchor.</li>
                    <li><strong>Check</strong> the new relation versus that concept (N up, S down, E analogue, W opposite).</li>
                    <li>If a letter must satisfy two relations, use a <em>compound nuance</em> (“chaotic example”, “burst light”) while keeping identity.</li>
                    <li><strong>Reframe</strong> only if the old choice breaks consistency across trials; if you reframe, note it.</li>
                    <li><strong>Infer context across letters:</strong> if K is north of J and P is above K, then P sits above J as well (transitively in your mental map). Keep your analogies coherent with such inferences while remembering the game’s logical engine remains the final judge of matches.</li>
                </ul>

                <p class="closing"><strong>Mantra:</strong> Anchor → Transform → Cohere → Commit → Recall → Update.</p>

                <div class="actions">
                    <button id="walkthroughN2Speak">Read this walkthrough aloud</button>
                    <button id="walkthroughN2Copy">Copy walkthrough text</button>
                </div>
            </div>
            `;

            mount.innerHTML = html;

            const speakBtn = mount.querySelector('#walkthroughN2Speak');
            const copyBtn = mount.querySelector('#walkthroughN2Copy');

            if (speakBtn) {
                speakBtn.addEventListener('click', () => {
                    if (typeof speakOnce === 'function') {
                        speakOnce(walkthroughN2SpeechText());
                    }
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    const source = mount.querySelector('#walkthroughN2');
                    if (!source) return;
                    const text = source.innerText.trim();
                    try {
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            await navigator.clipboard.writeText(text);
                        } else {
                            window.prompt('Copy this walkthrough text:', text);
                        }
                    } catch (err) {
                        console.warn('Clipboard write failed', err);
                        window.prompt('Copy this walkthrough text:', text);
                    }
                });
            }
        }

        (function registerWalkthroughN2Tab() {
            const tabs = document.getElementById('instTabs');
            if (!tabs) return;
            if (tabs.querySelector('button[data-tab="walkthrough-n2-10"]')) {
                return;
            }
            const btn = document.createElement('button');
            btn.textContent = 'n-Back-2: 10-Trial Walkthrough';
            btn.setAttribute('data-tab', 'walkthrough-n2-10');
            tabs.appendChild(btn);
        })();

        async function speakOnce(text) {
            if (!text) return;
            if (!engine || !engine.voice) return;
            if (typeof engine.voice.cancelAndWait === 'function') {
                await engine.voice.cancelAndWait();
            }
            engine.voice.speak(text, engine.voice.sessionToken);
        }

        const SANDBOX_TRANSFORMS = {
            N: {
                forward: (value) => `Up-shift(${value})`,
                reverse: (value) => `Down-shift(${value})`
            },
            S: {
                forward: (value) => `Down-shift(${value})`,
                reverse: (value) => `Up-shift(${value})`
            },
            E: {
                forward: (value) => `Analogue(${value})`,
                reverse: (value) => `Analogue(${value})`
            },
            W: {
                forward: (value) => `Opposite(${value})`,
                reverse: (value) => `Opposite(${value})`
            }
        };

        const AdvancePolicy = Object.freeze({ ACTIVE: 'active', LISTEN: 'listen' });
        let session = null;

        function makeEpoch() {
            const cryptoSource = (typeof crypto !== 'undefined' && crypto?.getRandomValues)
                ? crypto.getRandomValues(new Uint32Array(1))[0]
                : Date.now();
            const random = Math.floor(Math.random() * 1e9);
            return (cryptoSource ^ random) >>> 0;
        }

        function newSession(engine) {
            return {
                epoch: makeEpoch(),
                numTrials: engine.applyNumTrialsFromUI(),
                trialIndex: 0,
                policy: loadListenOnly() ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                abort: new AbortController(),
                trialToken: 0,
                phaseToken: 0,
                omissions: 0
            };
        }

        function valid(sess, trialToken, phaseToken) {
            return Boolean(
                session &&
                sess &&
                sess.epoch === session.epoch &&
                trialToken === session.trialToken &&
                (!phaseToken || phaseToken === session.phaseToken) &&
                !sess.abort.signal.aborted
            );
        }

        const SpeechGate = {
            trialSpeakId: 0,
            inFlight: false,
            explicitRepeatPhase: 0,
            flightToken: null
        };

        function resetSpeechGateForTrial() {
            SpeechGate.trialSpeakId += 1;
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
        }

        function noteExplicitRepeat() {
            SpeechGate.explicitRepeatPhase += 1;
        }

        const TTSMon = { starts: 0, ends: 0 };

        function instrumentUtterance(utterance) {
            if (!utterance || typeof utterance.addEventListener !== 'function') {
                return;
            }
            utterance.addEventListener('start', () => { TTSMon.starts += 1; });
            utterance.addEventListener('end', () => { TTSMon.ends += 1; });
        }

        if (typeof window !== 'undefined') {
            window.SpeechGate = SpeechGate;
            window.TTSMon = TTSMon;
        }

        const Timer = (() => {
            let id = 0;
            const live = new Map();

            function clear(timerId) {
                const entry = live.get(timerId);
                if (!entry) return;
                clearTimeout(entry.handle);
                live.delete(timerId);
            }

            function set(label, ms, trialToken, signal, cb) {
                const timerId = ++id;
                const handle = setTimeout(() => {
                    if (!valid(session, trialToken)) {
                        clear(timerId);
                        return;
                    }
                    live.delete(timerId);
                    cb?.();
                }, ms);
                live.set(timerId, { handle, label, trialToken, started: performance.now() });
                if (signal) {
                    signal.addEventListener('abort', () => clear(timerId), { once: true });
                }
                return timerId;
            }

            function cancelAll() {
                for (const entry of live.values()) {
                    clearTimeout(entry.handle);
                }
                live.clear();
            }

            return { set, clear, cancelAll, live };
        })();

        let heartbeat = null;

        function clearHeartbeat() {
            if (heartbeat) {
                clearInterval(heartbeat);
                heartbeat = null;
            }
        }

        function loadNumTrials() {
            const v = parseInt(localStorage.getItem(NUM_TRIALS_KEY) || '20', 10);
            const clamped = Math.min(10000, Math.max(1, isNaN(v) ? 20 : v));
            numTrialsInput.value = String(clamped);
            numTrialsSlider.value = String(Math.min(500, clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            return clamped;
        }

        function persistNumTrials(v) {
            const clamped = Math.min(10000, Math.max(1, v | 0));
            localStorage.setItem(NUM_TRIALS_KEY, String(clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            if (clamped <= 500) numTrialsSlider.value = String(clamped);
            numTrialsInput.value = String(clamped);
            return clamped;
        }

        numTrialsInput.addEventListener('change', () => {
            const value = parseInt(numTrialsInput.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        numTrialsSlider.addEventListener('input', () => {
            const value = parseInt(numTrialsSlider.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        const initialNumTrials = loadNumTrials();

        function sessionDefaults() {
            return {
                state: "STOPPED",
                trialIndex: 0,
                numTrials: initialNumTrials,
                seedSession: null,
                n: parseInt(document.getElementById('n-slider').value, 10),
                k: parseInt(document.getElementById('k-slider').value, 10),
                secondsPerTrial: parseFloat(document.getElementById('spt-slider').value)
            };
        }


        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(atoms) {
                this.atoms = [...atoms].sort((a, b) => {
                    if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                    if (a.head !== b.head) return a.head.localeCompare(b.head);
                    return a.tail.localeCompare(b.tail);
                });
                this.features = this.computeFeatures();
            }

            getLetters() {
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeFeatures() {
                const lettersSet = new Set();
                const degreeVector = new Map();
                const axisProfile = new Map();
                const indexMap = {
                    N: [0, 1],
                    S: [2, 3],
                    E: [4, 5],
                    W: [6, 7]
                };

                const ensureVector = (letter) => {
                    if (!degreeVector.has(letter)) {
                        degreeVector.set(letter, [0, 0, 0, 0, 0, 0, 0, 0]);
                    }
                    return degreeVector.get(letter);
                };

                this.atoms.forEach(atom => {
                    lettersSet.add(atom.head);
                    lettersSet.add(atom.tail);

                    const [outIdx, inIdx] = indexMap[atom.axis];
                    const headVec = ensureVector(atom.head);
                    headVec[outIdx] += 1;
                    const tailVec = ensureVector(atom.tail);
                    tailVec[inIdx] += 1;

                    axisProfile.set(atom.axis, (axisProfile.get(atom.axis) || 0) + 1);
                });

                return {
                    lettersSet,
                    degreeVector,
                    skeletonIsoSignature: this.isoSignature(),
                    atomAxisProfile: axisProfile
                };
            }

            getFeatures() {
                return this.features;
            }

            atomKeys() {
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                return this.atomKeys().join('|');
            }

            toString() {
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            analyze(allAtoms) {
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            lettersOf(premise) {
                const letters = new Set();
                premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeInvertibleMapping(atomsA, atomsB) {
                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const ok = search(0);
                return ok ? mapping.slice() : null;
            }

            analyzeMidWindow(midAtoms) {
                if (!midAtoms || midAtoms.length === 0) {
                    return { ok: false };
                }
                const solver = new ConstraintSolver();
                const analysis = solver.analyze(midAtoms);
                if (!analysis.ok) {
                    return { ok: false };
                }
                const reachX = buildReachability(analysis.nodesX, analysis.graphX);
                const reachY = buildReachability(analysis.nodesY, analysis.graphY);
                return { ok: true, analysis, reachX, reachY };
            }

            isDerivableFromMid(atom, midInfo) {
                if (!midInfo.ok) return false;
                const { analysis, reachX, reachY } = midInfo;
                if (atom.axis === 'N') {
                    const lesser = analysis.ufY.find(atom.tail);
                    const greater = analysis.ufY.find(atom.head);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'S') {
                    const lesser = analysis.ufY.find(atom.head);
                    const greater = analysis.ufY.find(atom.tail);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'E') {
                    const lesser = analysis.ufX.find(atom.tail);
                    const greater = analysis.ufX.find(atom.head);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'W') {
                    const lesser = analysis.ufX.find(atom.head);
                    const greater = analysis.ufX.find(atom.tail);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                return false;
            }

            Equivalent(premA, premB, windowAtoms = [], midAtoms = []) {
                const atomsA = premA.atoms;
                const atomsB = premB.atoms;

                if (atomsA.length !== atomsB.length) {
                    return { ok: false, reason: 'parity' };
                }

                const mapping = this.computeInvertibleMapping(atomsA, atomsB);
                if (!mapping) {
                    return { ok: false, reason: 'mapping' };
                }

                const lettersA = this.lettersOf(premA);
                const lettersB = this.lettersOf(premB);
                const shared = new Set();
                lettersA.forEach(letter => {
                    if (lettersB.has(letter)) {
                        shared.add(letter);
                    }
                });
                if (shared.size < 2) {
                    return { ok: false, reason: 'anchors' };
                }

                const solver = new ConstraintSolver();
                const satResult = solver.analyze([...windowAtoms, ...atomsA, ...atomsB]);
                if (!satResult.ok) {
                    return { ok: false, reason: 'sat' };
                }

                const midInfo = this.analyzeMidWindow(midAtoms);
                if (midInfo.ok) {
                    for (const atom of [...atomsA, ...atomsB]) {
                        if (this.isDerivableFromMid(atom, midInfo) || this.isDerivableFromMid(Atom.invert(atom), midInfo)) {
                            return {
                                ok: false,
                                reason: 'mid-window-derivable',
                                mapping,
                                sharedLetters: Array.from(shared),
                                midWindowDerivable: true
                            };
                        }
                    }
                }

                return {
                    ok: true,
                    type: 'invertible',
                    mapping,
                    sharedLetters: Array.from(shared),
                    midWindowDerivable: false
                };
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms, windowAtoms = []) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                const result = this.Equivalent(nBackPremise, candidatePremise, windowAtoms, midAtoms || []);
                if (!result.ok) {
                    const response = { match: false, reason: result.reason };
                    if (result.reason === 'mid-window-derivable' || result.midWindowDerivable) {
                        response.midWindowDerivable = true;
                        if (this.transitivityEnabled) {
                            return {
                                match: true,
                                certificate: {
                                    type: 'invertible',
                                    mapping: result.mapping || [],
                                    sharedLetters: result.sharedLetters || [],
                                    parity: true,
                                    midWindowDerivable: true
                                },
                                midWindowDerivable: true
                            };
                        }
                    }
                    return response;
                }

                const certificate = {
                    type: result.type,
                    mapping: result.mapping,
                    sharedLetters: result.sharedLetters,
                    parity: true,
                    midWindowDerivable: false
                };

                return { match: true, certificate, midWindowDerivable: false };
            }
        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
                this.matchModeBag = [];
                this.decoyModeBag = [];
                this.foilRate = conflictConfig.foilRate;
                this.foilTypes = Object.keys(conflictConfig.foilTypesWeights);
                this.foilWeights = this.foilTypes.map(type => conflictConfig.foilTypesWeights[type]);
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            chooseConflictMode(plannedMatch) {
                if (plannedMatch) {
                    if (this.matchModeBag.length === 0) {
                        this.matchModeBag = this.rng.shuffle(['BSM', 'CAC']);
                    }
                    return this.matchModeBag.pop();
                }
                if (this.decoyModeBag.length === 0) {
                    const decoys = ['ASNM', 'APNM', 'PPHF', 'CBB', 'WLC', 'ISD'];
                    const bag = [];
                    for (let i = 0; i < 2; i++) {
                        bag.push(...decoys);
                    }
                    this.decoyModeBag = this.rng.shuffle(bag);
                }
                return this.decoyModeBag.pop();
            }

            sampleFoilType() {
                if (this.foilTypes.length === 0) {
                    return null;
                }
                return this.rng.weightedChoice(this.foilTypes, this.foilWeights);
            }

            maybePlanFoil() {
                if (this.foilRate <= 0) return null;
                if (this.rng.next() < this.foilRate) {
                    const type = this.sampleFoilType();
                    return type ? { type } : null;
                }
                return null;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor(limitBytes = 5 * 1024 * 1024) {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeLimit = limitBytes;
                this.sizeEstimate = 0;
            }

            estimateSize(entry) {
                try {
                    return JSON.stringify(entry).length;
                } catch (error) {
                    return 0;
                }
            }

            flushToArchive() {
                const keep = Math.min(1000, this.entries.length);
                const flushCount = this.entries.length - keep;
                if (flushCount <= 0) return false;
                const flushedEntries = this.entries.splice(0, flushCount);
                const flushedSizes = this.entrySizes.splice(0, flushCount);
                this.archivedChunks.push(JSON.stringify(flushedEntries));
                const reclaimed = flushedSizes.reduce((acc, value) => acc + value, 0);
                this.sizeEstimate = Math.max(0, this.sizeEstimate - reclaimed);
                return true;
            }

            add(entry) {
                const size = this.estimateSize(entry);
                this.entries.push(entry);
                this.entrySizes.push(size);
                this.sizeEstimate += size;
                while (this.sizeEstimate > this.sizeLimit) {
                    const flushed = this.flushToArchive();
                    if (!flushed) {
                        break;
                    }
                }
            }

            reset() {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeEstimate = 0;
            }

            getEntriesSnapshot() {
                const snapshot = [];
                for (const chunk of this.archivedChunks) {
                    try {
                        const parsed = JSON.parse(chunk);
                        if (Array.isArray(parsed)) {
                            snapshot.push(...parsed);
                        }
                    } catch (error) {
                        console.warn('Failed to parse archived log chunk', error);
                    }
                }
                snapshot.push(...this.entries);
                return snapshot;
            }

            toCSV() {
                const entries = this.getEntriesSnapshot();
                if (entries.length === 0) return '';
                const headers = Object.keys(entries[0]);
                const rows = [headers.join(',')];
                entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.getEntriesSnapshot(), null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                premise.atoms.forEach(atom => {
                    this.ensureLetterUsage(atom.head).head += 1;
                    this.ensureLetterUsage(atom.tail).tail += 1;
                    this.axisUsage[atom.axis] += 1;
                });
            }

            recordPremise(premise, atoms, metadata) {
                this.constraintStore.push({ step: this.currentStep, atoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
                this.planner = null;
            }

            setPlanner(planner) {
                this.planner = planner;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride,
                    foilPlan
                } = options;

                const windowAtoms = this.state.getWindowAtoms();
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;
                const effectiveMatch = plannedMatch && Boolean(nBackPremise);
                let mode = effectiveMatch ? 'BSM' : 'ASNM';
                if (this.planner) {
                    mode = this.planner.chooseConflictMode(effectiveMatch);
                }

                let activeFoilPlan = (!effectiveMatch && foilPlan && typeof foilPlan.type === 'string') ? { type: foilPlan.type } : null;
                let foilAttempts = 0;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;

                    let candidatePremise = null;
                    let candidateAtoms = null;
                    let modeUsed = mode;
                    let foilType = null;

                    if (!effectiveMatch && activeFoilPlan && nBackPremise) {
                        const foilResult = this.buildFoilPremise(activeFoilPlan.type, {
                            referencePremise: nBackPremise,
                            windowAtoms,
                            middleAtoms,
                            avoidLetters
                        });
                        foilAttempts++;
                        if (foilResult) {
                            candidatePremise = foilResult.premise;
                            candidateAtoms = candidatePremise.atoms;
                            foilType = foilResult.foilType;
                            modeUsed = `FOIL_${foilResult.foilType}`;
                        } else if (foilAttempts >= 60) {
                            activeFoilPlan = null;
                        }
                    }

                    if (!candidatePremise) {
                        const pool = this.state.letterPool.nextPool(k, { expand });
                        const context = {
                            mode,
                            plannedMatch: effectiveMatch,
                            nBackPremise,
                            pool,
                            k,
                            n,
                            trialIndex,
                            middleAtoms,
                            avoidLetters,
                            state: this.state,
                            rng: this.state.rng
                        };
                        const atomsFromMode = this.makePremiseWithMode(mode, context);
                        attempts++;
                        if (!atomsFromMode) {
                            if (attempts % 12 === 0 && this.planner) {
                                mode = this.planner.chooseConflictMode(effectiveMatch);
                            }
                            continue;
                        }
                        candidateAtoms = atomsFromMode;
                        candidatePremise = new Premise(atomsFromMode);
                    } else {
                        attempts++;
                        candidateAtoms = candidatePremise.atoms;
                    }

                    const premise = candidatePremise;
                    const features = premise.getFeatures();
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, candidateAtoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (effectiveMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else if (nBackPremise) {
                        const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (check.match) {
                            continue;
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts,
                            modeUsed,
                            features,
                            foilType,
                            score
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }

                    if (attempts % 12 === 0 && this.planner) {
                        mode = this.planner.chooseConflictMode(effectiveMatch);
                    }
                }

                return bestCandidate;
            }

            makePremiseWithMode(mode, context) {
                const requiresNBack = ['ASNM', 'APNM', 'PPHF', 'BSM', 'WLC', 'CAC', 'ISD'];
                if (!context.nBackPremise && requiresNBack.includes(mode)) {
                    return this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
                switch (mode) {
                    case 'ASNM':
                        return this.makeAxisSwapNearMiss(context);
                    case 'APNM':
                        return this.makeAnchorPermutationNearMiss(context);
                    case 'PPHF':
                        return this.makeParityPreservedHubFlip(context);
                    case 'CBB':
                        return this.makeCycleBorderBait(context);
                    case 'BSM':
                        return this.makeBipartiteSignatureMatch(context);
                    case 'WLC':
                        return this.makeWrongLagCamouflage(context);
                    case 'CAC':
                        return this.makeCrossAxisCoupling(context);
                    case 'ISD':
                        return this.makeIsomorphicSkeletonDecoy(context);
                    default:
                        return context.plannedMatch
                            ? this.buildMatchCandidate(context.nBackPremise, context.pool, context.k)
                            : this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
            }

            buildFoilPremise(type, context) {
                const { referencePremise, windowAtoms, middleAtoms, avoidLetters } = context;
                if (!referencePremise) return null;
                const maxAttempts = 80;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let candidate = null;
                    switch (type) {
                        case 'ANCHOR_ONE':
                            candidate = this.makeAnchorOneFoil(referencePremise);
                            break;
                        case 'PAIR_SWAP':
                            candidate = this.makePairSwapFoil(referencePremise);
                            break;
                        case 'PARITY_OFF':
                            candidate = this.makeParityOffFoil(referencePremise);
                            break;
                        case 'AXIS_ORTHO':
                            candidate = this.makeAxisOrthoFoil(referencePremise);
                            break;
                        case 'DERIVED_IN_ONE':
                            candidate = this.makeDerivedInOneFoil(referencePremise);
                            break;
                        case 'WINDOW_SHADOW':
                            candidate = this.makeWindowShadowFoil(referencePremise, middleAtoms);
                            break;
                        default:
                            candidate = null;
                    }
                    if (!candidate) {
                        continue;
                    }
                    if (avoidLetters) {
                        const letters = candidate.getLetters();
                        let blocked = false;
                        avoidLetters.forEach(letter => {
                            if (letters.has(letter)) {
                                blocked = true;
                            }
                        });
                        if (blocked) continue;
                    }
                    const sat = this.solver.evaluate(windowAtoms, candidate.atoms);
                    if (!sat.ok) {
                        continue;
                    }
                    const eq = this.equivalence.Equivalent(referencePremise, candidate, windowAtoms, middleAtoms);
                    if (eq.ok) {
                        continue;
                    }
                    if (!this.foilReasonMatches(type, eq.reason)) {
                        continue;
                    }
                    return { premise: candidate, foilType: type };
                }
                return null;
            }

            foilReasonMatches(type, reason) {
                const expected = {
                    ANCHOR_ONE: 'anchors',
                    PAIR_SWAP: 'mapping',
                    PARITY_OFF: 'parity',
                    AXIS_ORTHO: 'mapping',
                    DERIVED_IN_ONE: 'parity',
                    WINDOW_SHADOW: 'mid-window-derivable'
                };
                const matchReason = expected[type];
                if (!matchReason) return true;
                if (matchReason === reason) return true;
                if (type === 'DERIVED_IN_ONE' && reason === 'mid-window-derivable') return true;
                return false;
            }

            makeAnchorOneFoil(referencePremise) {
                const refLetters = referencePremise.getLetters();
                const refArray = Array.from(refLetters);
                if (refArray.length === 0) return null;
                const anchor = this.state.rng.choice(refArray);
                const banned = new Set(refLetters);
                banned.delete(anchor);
                const available = this.state.letters.filter(letter => !banned.has(letter));
                if (available.length === 0) return null;
                const atoms = [];
                for (const atom of referencePremise.atoms) {
                    const axis = atom.axis;
                    const head = atom.head === anchor ? anchor : this.state.rng.choice(available);
                    let tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                    let guard = 0;
                    while (tail === head && guard < 12) {
                        tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                        guard++;
                    }
                    if (tail === head) return null;
                    atoms.push(new Atom(axis, head, tail));
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refLetters.has(letter));
                if (shared.length !== 1 || shared[0] !== anchor) return null;
                return premise;
            }

            makePairSwapFoil(referencePremise) {
                const atoms = referencePremise.atoms;
                if (atoms.length < 2) return null;
                const heads = atoms.map(atom => atom.head);
                const tails = atoms.map(atom => atom.tail);
                for (let attempt = 0; attempt < 40; attempt++) {
                    const shuffledHeads = this.state.rng.shuffle(heads);
                    const shuffledTails = this.state.rng.shuffle(tails);
                    const candidates = [];
                    const usedKeys = new Set();
                    let valid = true;
                    for (let i = 0; i < atoms.length; i++) {
                        let head = shuffledHeads[i];
                        let tail = shuffledTails[i];
                        let guard = 0;
                        while (head === tail && guard < 8) {
                            tail = this.state.rng.choice(tails);
                            guard++;
                        }
                        if (head === tail) {
                            valid = false;
                            break;
                        }
                        const atomCandidate = new Atom(atoms[i].axis, head, tail);
                        const key = atomCandidate.toKey();
                        if (usedKeys.has(key)) {
                            valid = false;
                            break;
                        }
                        if (atomCandidate.equals(atoms[i]) || atomCandidate.equals(Atom.invert(atoms[i]))) {
                            valid = false;
                            break;
                        }
                        usedKeys.add(key);
                        candidates.push(atomCandidate);
                    }
                    if (!valid) continue;
                    const premise = new Premise(candidates);
                    if (premise.toKey() === referencePremise.toKey()) continue;
                    return premise;
                }
                return null;
            }

            makeParityOffFoil(referencePremise) {
                const refSet = referencePremise.getLetters();
                const refLetters = Array.from(refSet);
                const base = this.cloneAtoms(referencePremise);
                const originalLength = base.length;
                if (originalLength === 0) return null;
                let target = originalLength;
                if (originalLength === 1) {
                    target = Math.min(4, 2);
                } else if (originalLength === 4) {
                    target = 3;
                } else {
                    const delta = this.state.rng.next() < 0.5 ? -1 : 1;
                    target = Math.min(4, Math.max(1, originalLength + delta));
                    if (target === originalLength) {
                        target = Math.max(1, Math.min(4, originalLength - delta));
                    }
                    if (target === originalLength) {
                        target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                    }
                }
                if (target === originalLength) {
                    target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                }
                if (target < 1) target = 1;
                let atoms = base;
                if (target < originalLength) {
                    atoms = base.slice();
                    while (atoms.length > target) {
                        const index = this.state.rng.nextInt(0, atoms.length - 1);
                        atoms.splice(index, 1);
                    }
                } else if (target > originalLength) {
                    atoms = base.slice();
                    const axes = MATCH_AXES;
                    let guard = 0;
                    while (atoms.length < target && guard < 60) {
                        guard++;
                        const head = this.state.rng.choice(refLetters);
                        let tail = this.state.rng.choice(refLetters);
                        if (tail === head) {
                            const alternative = this.sampleNewLetter(new Set([...refLetters]));
                            if (alternative) {
                                tail = alternative;
                            }
                        }
                        if (tail === head) continue;
                        const axis = this.state.rng.choice(axes);
                        const candidate = new Atom(axis, head, tail);
                        if (atoms.some(atom => atom.toKey() === candidate.toKey())) continue;
                        atoms.push(candidate);
                    }
                    if (atoms.length !== target) return null;
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refSet.has(letter));
                if (shared.length < 2) return null;
                return premise;
            }

            makeAxisOrthoFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const index = this.state.rng.nextInt(0, base.length - 1);
                const orthMap = { N: 'E', S: 'W', E: 'N', W: 'S' };
                const axis = orthMap[base[index].axis];
                if (!axis) return null;
                base[index] = new Atom(axis, base[index].head, base[index].tail);
                return new Premise(base);
            }

            makeDerivedInOneFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const additions = [];
                for (let i = 0; i < base.length; i++) {
                    for (let j = 0; j < base.length; j++) {
                        if (i === j) continue;
                        const a = base[i];
                        const b = base[j];
                        if (a.axis !== b.axis) continue;
                        if (a.tail === b.head && a.head !== b.tail) {
                            const candidate = new Atom(a.axis, a.head, b.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                        if (b.tail === a.head && b.head !== a.tail) {
                            const candidate = new Atom(a.axis, b.head, a.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                    }
                }
                if (additions.length === 0) return null;
                base.push(this.state.rng.choice(additions));
                return new Premise(base);
            }

            makeWindowShadowFoil(referencePremise, middleAtoms) {
                if (!middleAtoms || middleAtoms.length === 0) return null;
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const refLetters = referencePremise.getLetters();
                const options = middleAtoms.filter(atom => {
                    const already = base.some(existing => existing.equals(atom));
                    return !already && (refLetters.has(atom.head) || refLetters.has(atom.tail));
                });
                if (options.length === 0) return null;
                const replacement = this.state.rng.choice(options);
                const index = this.state.rng.nextInt(0, base.length - 1);
                base[index] = new Atom(replacement.axis, replacement.head, replacement.tail);
                return new Premise(base);
            }

            cloneAtoms(premise) {
                return premise.atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
            }

            sampleNewLetter(excludeSet = new Set()) {
                const candidates = this.state.letters.filter(letter => !excludeSet.has(letter));
                if (candidates.length === 0) return null;
                return this.state.rng.choice(candidates);
            }

            normalizeAtomCount(atoms, pool, target, avoidLetters, options = {}) {
                if (!atoms) return null;
                const clones = atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
                const required = new Set();
                if (typeof options.requiredIndex === 'number') {
                    required.add(options.requiredIndex);
                }
                if (Array.isArray(options.requiredIndices)) {
                    options.requiredIndices.forEach(idx => required.add(idx));
                }

                const result = [];
                const usedKeys = new Set();
                const pushAtom = (atom) => {
                    const key = atom.toKey();
                    if (usedKeys.has(key)) return false;
                    result.push(atom);
                    usedKeys.add(key);
                    return true;
                };

                for (const idx of required) {
                    if (idx >= 0 && idx < clones.length) {
                        pushAtom(clones[idx]);
                    }
                }

                for (let i = 0; i < clones.length && result.length < target; i++) {
                    if (required.has(i)) continue;
                    pushAtom(clones[i]);
                }

                const poolLetters = pool.length > 0 ? pool : this.state.letters;
                let attempts = 0;
                while (result.length < target && attempts < 200) {
                    attempts++;
                    const head = this.state.rng.choice(poolLetters);
                    if (avoidLetters && avoidLetters.has(head)) continue;
                    let tailCandidates = poolLetters.filter(letter => letter !== head);
                    if (avoidLetters) {
                        tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                    }
                    if (tailCandidates.length === 0) continue;
                    const tail = this.state.rng.choice(tailCandidates);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    const atom = new Atom(axis, head, tail);
                    if (usedKeys.has(atom.toKey())) continue;
                    pushAtom(atom);
                }

                if (result.length !== target) return null;
                return result;
            }

            makeAxisSwapNearMiss({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise || nBackPremise.atoms.length === 0) return null;
                const base = this.cloneAtoms(nBackPremise);
                const index = this.state.rng.nextInt(0, base.length - 1);
                const axisOptions = MATCH_AXES.filter(axis => axis !== base[index].axis);
                if (axisOptions.length === 0) return null;
                base[index] = new Atom(this.state.rng.choice(axisOptions), base[index].head, base[index].tail);
                return this.normalizeAtomCount(base, pool, k, avoidLetters, { requiredIndex: index });
            }

            makeAnchorPermutationNearMiss({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length < 2) return null;
                const anchor = this.state.rng.choice(letters);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of letters) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, null);
            }

            makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise) return null;
                const counts = new Map();
                nBackPremise.atoms.forEach(atom => {
                    counts.set(atom.head, (counts.get(atom.head) || 0) + 1);
                    counts.set(atom.tail, (counts.get(atom.tail) || 0) + 1);
                });
                const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
                if (!sorted.length || sorted[0][1] < 2) return null;
                const hub = sorted[0][0];
                const exclude = new Set(nBackPremise.getLetters());
                let newHub = this.sampleNewLetter(exclude);
                if (!newHub) return null;
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = atom.head === hub ? newHub : atom.head;
                    const tail = atom.tail === hub ? newHub : atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeCycleBorderBait({ k, pool, avoidLetters }) {
                const uniquePool = Array.from(new Set(pool));
                const targetLetters = Math.max(3, Math.min(k + 1, 6));
                const letters = [];
                const used = new Set();
                const shuffled = this.state.rng.shuffle(uniquePool);
                for (const letter of shuffled) {
                    if (letters.length >= targetLetters) break;
                    letters.push(letter);
                    used.add(letter);
                }
                while (letters.length < targetLetters) {
                    const next = this.sampleNewLetter(used);
                    if (!next) break;
                    letters.push(next);
                    used.add(next);
                }
                if (letters.length < 3) return null;
                const axes = ['N', 'E', 'S', 'W'];
                const atoms = [];
                for (let i = 0; i < Math.min(k, letters.length - 1); i++) {
                    const axis = axes[i % axes.length];
                    atoms.push(new Atom(axis, letters[i], letters[i + 1]));
                }
                if (atoms.length < k) {
                    const axis = axes[atoms.length % axes.length];
                    const head = letters[letters.length - 1];
                    const tailIndex = letters.length > 2 ? 1 : 0;
                    atoms.push(new Atom(axis, head, letters[tailIndex]));
                }
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeBipartiteSignatureMatch({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const targetFeatures = nBackPremise.getFeatures();
                for (let attempt = 0; attempt < 12; attempt++) {
                    const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    if (candidate.toKey() === nBackPremise.toKey()) continue;
                    if (!this.compareDegreeVectors(candidate.getFeatures().degreeVector, targetFeatures.degreeVector)) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeWrongLagCamouflage({ trialIndex, n, state, pool, k }) {
                let altPremise = null;
                if (n > 1) {
                    altPremise = state.getPremiseAt(trialIndex - (n - 1));
                }
                if (!altPremise) {
                    altPremise = state.getPremiseAt(trialIndex - (n + 1));
                }
                if (!altPremise) return null;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const atoms = this.buildMatchCandidate(altPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    const equivalence = this.equivalence.computeCertificate(altPremise, candidate, []);
                    if (!equivalence.match) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeCrossAxisCoupling(context) {
                const { nBackPremise, pool, k, plannedMatch, avoidLetters } = context;
                if (!nBackPremise) {
                    return plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                }
                if (plannedMatch) {
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                        if (!atoms) return null;
                        const candidate = new Premise(atoms);
                        if (candidate.toKey() === nBackPremise.toKey()) continue;
                        if (!this.hasCrossAxisCoupling(nBackPremise, candidate)) continue;
                        return atoms;
                    }
                    return null;
                }
                const atoms = this.makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters });
                if (!atoms) return null;
                const candidate = new Premise(atoms);
                return this.hasCrossAxisCoupling(nBackPremise, candidate) ? atoms : null;
            }

            makeIsomorphicSkeletonDecoy({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length === 0) return null;
                const sorted = [...letters].sort();
                const anchor = this.state.rng.choice(sorted);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of sorted) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                const candidate = new Premise(atoms);
                if (candidate.isoSignature() !== nBackPremise.isoSignature()) {
                    return null;
                }
                return this.normalizeAtomCount(candidate.atoms, pool, k, null);
            }

            compareDegreeVectors(a, b) {
                if (a.size !== b.size) return false;
                for (const [letter, vecA] of a.entries()) {
                    const vecB = b.get(letter);
                    if (!vecB) return false;
                    for (let i = 0; i < vecA.length; i++) {
                        if (vecA[i] !== vecB[i]) return false;
                    }
                }
                return true;
            }

            collectAxisUsage(premise) {
                const usage = new Map();
                const mark = (letter, axis) => {
                    if (!usage.has(letter)) {
                        usage.set(letter, { vertical: false, horizontal: false });
                    }
                    const entry = usage.get(letter);
                    if (axis === 'N' || axis === 'S') {
                        entry.vertical = true;
                    } else {
                        entry.horizontal = true;
                    }
                };
                premise.atoms.forEach(atom => {
                    mark(atom.head, atom.axis);
                    mark(atom.tail, atom.axis);
                });
                return usage;
            }

            hasCrossAxisCoupling(p1, p2) {
                const usage1 = this.collectAxisUsage(p1);
                const usage2 = this.collectAxisUsage(p2);
                const letters = new Set([...usage1.keys(), ...usage2.keys()]);
                for (const letter of letters) {
                    const info1 = usage1.get(letter) || { vertical: false, horizontal: false };
                    const info2 = usage2.get(letter) || { vertical: false, horizontal: false };
                    if ((info1.vertical || info2.vertical) && (info1.horizontal || info2.horizontal)) {
                        return true;
                    }
                }
                return false;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }
        }

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voice = null;
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.sessionToken = makeEpoch();
            }

            async initialize() {
                await new Promise(resolve => {
                    const attempt = () => {
                        const voices = this.synth.getVoices();
                        if (!voices || voices.length === 0) {
                            setTimeout(attempt, 200);
                            return;
                        }
                        this.selectVoice(voices);
                        this.voiceReady = true;
                        resolve();
                    };
                    attempt();
                });
            }

            selectVoice(voices) {
                const storedName = localStorage.getItem('relational-nback-voice-name');
                const storedLang = localStorage.getItem('relational-nback-voice-lang');

                if (storedName && storedLang) {
                    const stored = voices.find(v => v.name === storedName && v.lang === storedLang);
                    if (stored) {
                        this.voice = stored;
                        return;
                    }
                }

                const preferredLocales = ['en-AU', 'en-GB', 'en-US'];
                const feminineHints = ['Female', 'Karen', 'Natasha', 'Sonia', 'Serena', 'Aria', 'Samantha'];

                for (const locale of preferredLocales) {
                    const candidates = voices.filter(v => v.lang.startsWith(locale));
                    for (const hint of feminineHints) {
                        const match = candidates.find(v => v.name.includes(hint));
                        if (match) {
                            this.voice = match;
                            localStorage.setItem('relational-nback-voice-name', match.name);
                            localStorage.setItem('relational-nback-voice-lang', match.lang);
                            return;
                        }
                    }
                    if (candidates.length) {
                        this.voice = candidates[0];
                        return;
                    }
                }

                this.voice = voices[0] || null;
            }

            getVoiceInfo() {
                return this.voice ? `${this.voice.name} (${this.voice.lang})` : 'Voice not initialized';
            }

            getLockedVoice() {
                return this.voice;
            }

            async cancelAndWait() {
                try {
                    this.synth.cancel();
                } catch (error) {
                    console.warn('speechSynthesis.cancel failed', error);
                }
                await new Promise(resolve => setTimeout(resolve, 50));
                this.sessionToken = makeEpoch();
            }

            speak(text, guardToken = null) {
                if (!text) {
                    return Promise.resolve({ fallback: false, attempts: 0 });
                }

                return new Promise(resolve => {
                    if (guardToken && guardToken !== this.sessionToken) {
                        resolve({ fallback: false, attempts: 0 });
                        return;
                    }

                    const utterance = new SpeechSynthesisUtterance(text);
                    const voice = this.getLockedVoice();
                    if (voice) {
                        utterance.voice = voice;
                        utterance.lang = voice.lang;
                    }
                    utterance.pitch = this.pitch;
                    utterance.rate = this.rate;
                    utterance.volume = this.volume;

                    let settled = false;
                    const finish = (fallback) => {
                        if (settled) return;
                        settled = true;
                        clearTimeout(fallbackTimer);
                        resolve({ fallback, attempts: 1 });
                    };

                    const fallbackTimer = setTimeout(() => finish(true), estimateUtteranceMs(text, this.rate) + 400);

                    utterance.onend = () => finish(false);
                    utterance.onerror = () => finish(true);

                    setTimeout(() => {
                        if (settled) return;
                        if (guardToken && guardToken !== this.sessionToken) {
                            finish(true);
                            return;
                        }
                        try {
                            this.synth.resume();
                        } catch (err) {
                            console.warn('speechSynthesis.resume failed', err);
                        }
                        try {
                            this.synth.speak(utterance);
                        } catch (err) {
                            console.warn('speechSynthesis.speak failed', err);
                            finish(true);
                        }
                    }, 120);
                });
            }

            async speakPremise(premise, guardToken = null) {
                if (!premise) {
                    return { fallback: false, attempts: 0 };
                }
                const text = formatPremiseForSpeech(premise);
                return this.speak(text, guardToken);
            }
        }
        class GameEngine {
            constructor() {
                this.session = sessionDefaults();
                this.session.state = 'STOPPED';
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.awaitingResponse = false;
                this.sessionToken = makeEpoch();
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
                this.pendingRestart = false;
                this.statusMessage = 'Idle';
                this.policy = AdvancePolicy.ACTIVE;
                this.lastSpokenFallback = false;
                this.activePremise = null;
            }

            get n() {
                return this.session.n;
            }

            set n(value) {
                this.session.n = value;
            }

            get k() {
                return this.session.k;
            }

            set k(value) {
                this.session.k = value;
            }

            get secondsPerTrial() {
                return this.session.secondsPerTrial;
            }

            set secondsPerTrial(value) {
                this.session.secondsPerTrial = value;
            }

            get totalTrials() {
                return this.session.numTrials;
            }

            set totalTrials(value) {
                this.session.numTrials = value;
            }

            applyNumTrialsFromUI() {
                const current = loadNumTrials();
                this.session.numTrials = current;
                return current;
            }

            speakOnce(text) {
                if (!text) return;
                this.voice.speak(text, this.voice.sessionToken);
            }

            renderSummary() {
                this.statusMessage = `Session complete. ${this.session.numTrials} trials finished.`;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
            }

            async initialize() {
                await this.voice.initialize();
                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                if (window._imagiHandlersBound) {
                    return;
                }
                window._imagiHandlersBound = true;

                const lockSeedToggle = document.getElementById('lock-seed-toggle');
                if (lockSeedToggle) {
                    lockSeedToggle.checked = this.lockSeed;
                    lockSeedToggle.addEventListener('change', (e) => {
                        this.lockSeed = e.target.checked;
                        this.seedManager.setLockPreference(this.lockSeed);
                    });
                }

                const resetSeedToggle = document.getElementById('reset-seed-toggle');
                if (resetSeedToggle) {
                    resetSeedToggle.addEventListener('change', (e) => {
                        this.resetOnRestart = e.target.checked;
                    });
                }

                const transitivityToggle = document.getElementById('transitivity-toggle');
                if (transitivityToggle) {
                    transitivityToggle.addEventListener('change', (e) => {
                        this.equivalence.setTransitivity(e.target.checked);
                    });
                }

                const debugToggle = document.getElementById('debug-toggle');
                if (debugToggle) {
                    debugToggle.addEventListener('change', (e) => {
                        document.getElementById('debug').hidden = !e.target.checked;
                    });
                }

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    const sptValue = document.getElementById('spt-value');
                    if (sptValue) {
                        sptValue.textContent = this.secondsPerTrial.toFixed(1);
                    }
                };
                if (sptSlider) {
                    sptSlider.addEventListener('input', (e) => {
                        if (sptNumber) {
                            sptNumber.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }
                if (sptNumber) {
                    sptNumber.addEventListener('input', (e) => {
                        if (sptSlider) {
                            sptSlider.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }

                const nSlider = document.getElementById('n-slider');
                if (nSlider) {
                    nSlider.addEventListener('input', (e) => {
                        this.n = parseInt(e.target.value, 10);
                        const nValue = document.getElementById('n-value');
                        if (nValue) {
                            nValue.textContent = this.n;
                        }
                    });
                }

                const kSlider = document.getElementById('k-slider');
                if (kSlider) {
                    kSlider.addEventListener('input', (e) => {
                        this.k = parseInt(e.target.value, 10);
                        const kValue = document.getElementById('k-value');
                        if (kValue) {
                            kValue.textContent = this.k;
                        }
                    });
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        this.pendingRestart = false;
                        startSession();
                    });
                }

                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        restartSession();
                    });
                }

                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => {
                        stopSession();
                    });
                }

                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) {
                    repeatBtn.addEventListener('click', () => {
                        onRepeatPressed();
                    });
                }

                const previewBtn = document.getElementById('preview-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', async () => {
                        const previewPremise = new Premise([
                            new Atom('N', 'A', 'B'),
                            new Atom('E', 'C', 'D')
                        ]);
                        await this.voice.speakPremise(previewPremise, this.voice.sessionToken);
                    });
                }

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        const handler = window.__imagiActiveResponse;
                        if (typeof handler === 'function') {
                            e.preventDefault();
                            handler(e.code === 'Space' ? 'match' : 'nomatch');
                        }
                    }
                });

                const exportBtn = document.getElementById('export-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => {
                        this.exportData();
                    });
                }

                const testBtn = document.getElementById('test-btn');
                if (testBtn) {
                    testBtn.addEventListener('click', async () => {
                        const panel = document.getElementById('test-panel');
                        const resultsEl = document.getElementById('test-results');
                        if (panel) panel.hidden = false;
                        if (resultsEl) {
                            resultsEl.innerHTML = '<p>Running tests...</p>';
                            const harness = new TestHarness();
                            const results = await harness.runAll();
                            resultsEl.innerHTML = results.map(result => {
                                const cls = result.passed ? 'pass' : 'fail';
                                const symbol = result.passed ? '✓' : '✗';
                                return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                            }).join('');
                        }
                    });
                }
            }

            updateVoiceInfo() {
                const info = document.getElementById('voice-info');
                if (info) {
                    info.innerHTML = `<strong>Voice:</strong> ${this.voice.getVoiceInfo()}`;
                }
            }

            updateUI() {
                const trialCount = document.getElementById('trial-count');
                if (trialCount) {
                    trialCount.textContent = this.session.trialIndex;
                }
                const scoreEl = document.getElementById('score');
                if (scoreEl) {
                    scoreEl.textContent = this.score;
                }
                const omissionsEl = document.getElementById('omissions');
                if (omissionsEl) {
                    omissionsEl.textContent = this.omissions;
                }
                const accuracyEl = document.getElementById('accuracy');
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                if (accuracyEl) {
                    accuracyEl.textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                }
                const rollingEl = document.getElementById('rolling-acc');
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                if (rollingEl) {
                    rollingEl.textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';
                }

                const running = this.session.state === 'RUNNING';
                const statusText = running ? `Running (n=${this.n}, k=${this.k})` : this.statusMessage;
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = statusText;
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) startBtn.disabled = running;
                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) restartBtn.disabled = !running;
                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) stopBtn.disabled = !running;
            }

            prepareSession(sess) {
                const totalPlanned = sess.numTrials;
                this.session = sessionDefaults();
                this.session.trialIndex = 0;
                this.session.numTrials = totalPlanned;
                this.session.state = 'RUNNING';
                this.policy = sess.policy;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;
                this.awaitingResponse = false;
                this.lastSpokenFallback = false;

                const shouldResetLogs = !this.pendingRestart || this.resetOnRestart;
                this.pendingRestart = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.session.seedSession = seed;
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                this.planner = new MatchPlanner(this.state.rng);
                this.generator.setPlanner(this.planner);
                this.matchSchedule = this.planner.plan(totalPlanned, this.n);
                if (shouldResetLogs) {
                    this.logger.reset();
                }
                this.currentPremises = [];
                this.statusMessage = `Running (n=${this.n}, k=${this.k})`;
                this.sessionToken = makeEpoch();

                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = '';
                }
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) repeatBtn.disabled = true;
                const matchBtn = document.getElementById('match-btn');
                if (matchBtn) matchBtn.disabled = true;
                const noMatchBtn = document.getElementById('no-match-btn');
                if (noMatchBtn) noMatchBtn.disabled = true;
                window.__imagiActiveResponse = null;
                window.forceCurrentTrialTimeout = null;
                window.currentPremiseText = '';

                this.updateUI();
            }

            async finalizeSession(sess, aborted) {
                this.awaitingResponse = false;
                this.session.state = 'STOPPED';
                this.statusMessage = aborted ? 'Stopped' : `Session complete. ${this.session.numTrials} trials finished.`;
                if (!aborted) {
                    this.renderSummary();
                }
                this.activePremise = null;
                this.updateUI();
            }

            planTrial(trialIndex) {
                const scheduledMatch = this.matchSchedule[trialIndex] || false;
                const nBackIndex = trialIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, trialIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(trialIndex);
                const planMatch = scheduledMatch && Boolean(nBackPremise);
                const foilPlan = (!planMatch && nBackPremise) ? this.planner.maybePlanFoil() : null;
                return { trialIndex, scheduledMatch, nBackPremise, middleAtoms, cooldown, planMatch, foilPlan };
            }

            tryGenerate(plan, override = null) {
                const params = {
                    trialIndex: plan.trialIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch: override !== null ? override : plan.planMatch,
                    nBackPremise: plan.nBackPremise,
                    middleAtoms: plan.middleAtoms,
                    avoidLetters: (override !== null ? override : plan.planMatch) ? plan.cooldown : null,
                    allowOverride: true,
                    foilPlan: plan.foilPlan
                };
                return this.generator.generate(params);
            }

            async generatePremiseGuaranteed(plan) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const result = this.tryGenerate(plan, null);
                    if (result) {
                        return { ...result, planMatch: plan.planMatch };
                    }
                    if (plan.scheduledMatch && attempt === 0) {
                        this.planner.forceFlip(plan.trialIndex);
                        this.pendingPlannerFlip = true;
                        const flipped = this.tryGenerate(plan, false);
                        if (flipped) {
                            return { ...flipped, planMatch: false };
                        }
                    }
                }

                if (!plan._flipped && plan.nBackPremise) {
                    const flippedPlan = { ...plan, planMatch: !plan.planMatch, scheduledMatch: false, _flipped: true };
                    for (let attempt = 0; attempt < 30; attempt++) {
                        const result = this.tryGenerate(flippedPlan, flippedPlan.planMatch);
                        if (result) {
                            return { ...result, planMatch: flippedPlan.planMatch };
                        }
                    }
                }

                return this.buildNeutralNonMatch(plan);
            }

            buildNeutralNonMatch(plan) {
                const letters = this.state?.letters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const head = this.state?.rng ? this.state.rng.choice(letters) : letters[0];
                const tails = letters.filter(letter => letter !== head);
                const tail = (this.state?.rng ? this.state.rng.choice(tails.length ? tails : letters) : (tails[0] || letters[1] || head));
                const axis = this.state?.rng ? this.state.rng.choice(MATCH_AXES) : 'N';
                const safeTail = tail === head ? letters[(letters.indexOf(head) + 1) % letters.length] : tail;
                const premise = new Premise([new Atom(axis, head, safeTail)]);
                const signatures = this.state ? this.state.novelty.buildSignatures(premise) : { exact: premise.toKey() };
                const windowAtoms = this.state ? this.state.getWindowAtoms() : [];
                const satResult = this.solver ? this.solver.evaluate(windowAtoms, premise.atoms) : { ok: true, coordinates: new Map() };
                return {
                    premise,
                    signatures,
                    novelty: { noveltyScores: {}, blocked: false },
                    satResult,
                    certificate: null,
                    modeUsed: 'fallback',
                    features: premise.getFeatures(),
                    foilType: null,
                    planMatch: false
                };
            }

            async executeTrial(sess, trialToken, signal) {
                if (!valid(sess, trialToken)) return;
                resetSpeechGateForTrial();
                const currentIndex = sess.trialIndex;
                this.session.trialIndex = currentIndex;
                this.updateUI();

                let plan = this.planTrial(currentIndex);
                let result = await this.generatePremiseGuaranteed(plan);
                if (!result) {
                    console.warn('Premise generation returned null; using neutral fallback.');
                    result = this.buildNeutralNonMatch(plan);
                }

                const { premise, signatures, novelty, satResult, certificate, modeUsed, features, foilType, planMatch } = result;
                this.activePremise = premise;
                const planType = planMatch ? 'match' : (foilType ? `foil:${foilType}` : 'nonmatch');
                const featureSnapshot = features || premise.getFeatures();

                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch: planMatch, certificate, modeUsed, foilType });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                sess.phaseToken = (sess.phaseToken || 0) + 1;
                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = premise.toString();
                }
                window.currentPremiseText = formatPremiseForSpeech(premise);
                const matchBtn = document.getElementById('match-btn');
                const noMatchBtn = document.getElementById('no-match-btn');
                const repeatBtn = document.getElementById('repeat-btn');
                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = false;

                const speechMeta = await speakPremiseSafe(sess, premise, trialToken, signal);
                this.lastSpokenFallback = Boolean(speechMeta?.fallback);
                if (!valid(sess, trialToken)) return;

                if (sess.policy === AdvancePolicy.LISTEN) {
                    await dwellSafe(this.secondsPerTrial, trialToken, signal);
                    if (!valid(sess, trialToken)) return;
                    this.logTrial({
                        planMatch,
                        planType,
                        certificate,
                        featureSnapshot,
                        premise,
                        novelty,
                        satResult,
                        foilType,
                        responsePayload: { choice: null, correct: null, rt: null, omission: false, timeout: false },
                        modeUsed,
                        trialIndex: currentIndex,
                        passiveAdvance: true,
                        trialTokenAtStart: trialToken,
                        listenOnly: true
                    });
                    if (repeatBtn) repeatBtn.disabled = true;
                    const feedbackEl = document.getElementById('feedback');
                    if (feedbackEl) {
                        feedbackEl.textContent = 'Listening…';
                        feedbackEl.className = 'feedback';
                    }
                    this.session.trialIndex = currentIndex + 1;
                    this.updateUI();
                    this.activePremise = null;
                    return;
                }

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();
                if (matchBtn) matchBtn.disabled = false;
                if (noMatchBtn) noMatchBtn.disabled = false;

                const response = await collectResponseSafe(this.secondsPerTrial, trialToken, signal);
                this.awaitingResponse = false;
                if (!valid(sess, trialToken)) return;

                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = true;

                const responseChoice = response?.type === 'answer' ? response.choice : null;
                const timeout = response?.type === 'timeout';
                const omission = timeout || responseChoice === null;
                const actualMatch = Boolean(planMatch && certificate);
                let correct = null;
                if (!timeout && responseChoice !== null) {
                    correct = (responseChoice === 'match') === actualMatch;
                }

                if (timeout) {
                    this.omissions += 1;
                } else if (correct !== null) {
                    this.totalResponses += 1;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = (!timeout && responseChoice !== null) ? Date.now() - this.responseStartTime : null;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    if (timeout) {
                        feedbackEl.textContent = 'Response window expired.';
                        feedbackEl.className = 'feedback incorrect';
                    } else if (correct) {
                        feedbackEl.textContent = 'Correct';
                        feedbackEl.className = 'feedback correct';
                    } else if (correct === false) {
                        feedbackEl.textContent = 'Incorrect';
                        feedbackEl.className = 'feedback incorrect';
                    } else {
                        feedbackEl.textContent = '';
                        feedbackEl.className = 'feedback';
                    }
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), currentIndex, this.n);
                }

                this.logTrial({
                    planMatch,
                    planType,
                    certificate,
                    featureSnapshot,
                    premise,
                    novelty,
                    satResult,
                    foilType,
                    responsePayload: {
                        choice: responseChoice,
                        correct,
                        rt,
                        omission,
                        timeout
                    },
                    modeUsed,
                    trialIndex: currentIndex,
                    passiveAdvance: false,
                    trialTokenAtStart: trialToken,
                    listenOnly: false
                });

                this.activePremise = null;
                this.session.trialIndex = currentIndex + 1;
                this.updateUI();
            }

            logTrial({ planMatch, planType, certificate, featureSnapshot, premise, novelty, satResult, foilType, responsePayload, modeUsed, trialIndex, passiveAdvance, trialTokenAtStart, listenOnly }) {
                const { choice, correct, rt, omission, timeout } = responsePayload;
                const featureLog = {
                    lettersSet: Array.from(featureSnapshot.lettersSet).sort(),
                    degreeVector: {},
                    skeletonIsoSignature: featureSnapshot.skeletonIsoSignature,
                    atomAxisProfile: {}
                };
                featureSnapshot.degreeVector.forEach((vec, letter) => {
                    featureLog.degreeVector[letter] = [...vec];
                });
                featureSnapshot.atomAxisProfile.forEach((count, axis) => {
                    featureLog.atomAxisProfile[axis] = count;
                });

                const plannerFlip = this.pendingPlannerFlip || (this.planner && typeof this.planner.wasFlipped === 'function' ? this.planner.wasFlipped(trialIndex) : false);
                this.pendingPlannerFlip = false;

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex,
                    trialNumber: trialIndex + 1,
                    numTrials: this.session.numTrials,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch: planMatch,
                    planType,
                    foilType: foilType || null,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty?.noveltyScores || {},
                    response: { choice, correct, rtMs: rt, omission, timeout },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(trialIndex + 1)),
                    plannerFlip,
                    modeUsed,
                    mode: listenOnly ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                    passiveAdvance,
                    ttsFallback: Boolean(this.lastSpokenFallback),
                    trialTokenAtStart,
                    features: featureLog
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                if (!debug) return;
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Plan=${entry.planType} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.getEntriesSnapshot()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        const DEBOUNCE_MS = 250;
        let lastBtn = 0;

        function debounce() {
            const now = performance.now();
            if (now - lastBtn < DEBOUNCE_MS) return false;
            lastBtn = now;
            return true;
        }

        function cancelSpeechImmediately() {
            try {
                window.speechSynthesis?.cancel();
            } catch (err) {
                console.warn('speechSynthesis.cancel immediate failed', err);
            }
        }

        function clearAllEngineTimers() {
            Timer.cancelAll();
            clearHeartbeat();
        }

        function stopSession() {
            if (!session) return;
            try {
                session.abort.abort();
            } catch (err) {
                console.warn('abort stop failed', err);
            }
            clearAllEngineTimers();
            cancelSpeechImmediately();
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
            engine.finalizeSession(session, true);
            window.__imagiActiveResponse = null;
            window.forceCurrentTrialTimeout = null;
            session = null;
        }

        async function runLoop(sess) {
            const signal = sess.abort.signal;
            while (!signal.aborted && sess.trialIndex < sess.numTrials) {
                sess.trialToken += 1;
                sess.phaseToken = 0;
                await engine.executeTrial(sess, sess.trialToken, signal);
                if (signal.aborted) break;
                sess.trialIndex += 1;
            }
            if (!signal.aborted) {
                await engine.finalizeSession(sess, false);
                clearAllEngineTimers();
                session = null;
            }
        }

        function startSession() {
            if (!debounce()) return;
            stopSession();
            session = newSession(engine);
            engine.prepareSession(session);
            wireHeartbeat(session);
            runLoop(session).catch((err) => {
                console.error('runLoop error', err);
                stopSession();
            });
        }

        function restartSession() {
            if (!debounce()) return;
            stopSession();
            startSession();
        }

        function formatPremiseForSpeech(premise) {
            if (!premise) return '';
            return premise.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
        }

        function estimateUtteranceMs(text, rate = 0.9) {
            const cps = 12 * rate;
            return Math.max(900, Math.min(9000, Math.round((text.length / cps) * 1000) + 300));
        }

        async function speakPremiseSafe(sess, premise, trialToken, signal) {
            if (!valid(sess, trialToken)) {
                return { fallback: false, attempts: 0 };
            }

            return new Promise((resolve) => {
                const mySpeakId = SpeechGate.trialSpeakId;
                const myRepeatPhase = SpeechGate.explicitRepeatPhase;

                if (SpeechGate.inFlight) {
                    resolve({ fallback: false, attempts: 0 });
                    return;
                }

                const flightToken = Symbol('speech-flight');
                SpeechGate.inFlight = true;
                SpeechGate.flightToken = flightToken;

                try {
                    window.speechSynthesis?.cancel();
                } catch (err) {
                    console.warn('speechSynthesis.cancel before speak failed', err);
                }

                const text = formatPremiseForSpeech(premise);
                window.currentPremiseText = text;
                const utterance = new SpeechSynthesisUtterance(text);
                const lockedVoice = engine?.voice?.getLockedVoice?.();
                if (lockedVoice) {
                    utterance.voice = lockedVoice;
                    utterance.lang = lockedVoice.lang;
                }
                const pitch = engine?.voice?.pitch ?? 1.2;
                const rate = engine?.voice?.rate ?? 0.9;
                const volume = engine?.voice?.volume ?? 1.0;
                utterance.pitch = pitch;
                utterance.rate = rate;
                utterance.volume = volume;

                instrumentUtterance(utterance);

                let settled = false;

                const finish = (fallback) => {
                    if (settled) return;
                    settled = true;
                    if (SpeechGate.flightToken === flightToken) {
                        SpeechGate.inFlight = false;
                        SpeechGate.flightToken = null;
                    }
                    clearTimeout(fallbackTimer);
                    signal.removeEventListener('abort', onAbort);
                    resolve({ fallback, attempts: 1 });
                };

                const onAbort = () => finish(false);
                signal.addEventListener('abort', onAbort, { once: true });

                const fallbackTimer = setTimeout(() => {
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    finish(true);
                }, estimateUtteranceMs(text, rate) + 400);

                utterance.onend = () => finish(false);
                utterance.onerror = () => finish(true);

                setTimeout(() => {
                    if (settled) return;
                    if (!valid(sess, trialToken) || signal.aborted) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    try {
                        window.speechSynthesis?.resume();
                    } catch (err) {
                        console.warn('speechSynthesis.resume failed', err);
                    }
                    try {
                        window.speechSynthesis?.speak(utterance);
                    } catch (err) {
                        console.warn('speechSynthesis.speak failed', err);
                        finish(true);
                    }
                }, 100);
            });
        }

        function secondsPerTrial() {
            return engine.secondsPerTrial;
        }

        async function dwellSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                Timer.set('dwell', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, resolve);
            });
        }

        function bindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.addEventListener('click', onMatch, { once: true });
            noMatchBtn?.addEventListener('click', onNo, { once: true });
        }

        function unbindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.removeEventListener('click', onMatch);
            noMatchBtn?.removeEventListener('click', onNo);
        }

        async function collectResponseSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let settled = false;
                const settle = (payload) => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    resolve(payload);
                };

                const onMatch = () => settle({ type: 'answer', choice: 'match' });
                const onNo = () => settle({ type: 'answer', choice: 'nomatch' });
                bindTrialButtons(onMatch, onNo);
                window.__imagiActiveResponse = (choice) => {
                    if (choice === 'match') {
                        onMatch();
                    } else {
                        onNo();
                    }
                };

                const timerId = Timer.set('resp', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, () => settle({ type: 'timeout' }));

                const cleanup = () => {
                    unbindTrialButtons(onMatch, onNo);
                    Timer.clear(timerId);
                    window.__imagiActiveResponse = null;
                };

                signal.addEventListener('abort', () => settle({ type: 'timeout' }), { once: true });
                window.forceCurrentTrialTimeout = () => settle({ type: 'timeout' });
            });
        }

        function wireHeartbeat(sess) {
            clearHeartbeat();
            let lastTick = performance.now();
            let lastTrial = -1;
            heartbeat = setInterval(() => {
                if (!session || session.epoch !== sess.epoch) {
                    clearHeartbeat();
                    return;
                }
                if (sess.abort.signal.aborted) {
                    clearHeartbeat();
                    return;
                }
                const now = performance.now();
                if (sess.trialIndex !== lastTrial) {
                    lastTrial = sess.trialIndex;
                    lastTick = now;
                    return;
                }
                const typical = estimateUtteranceMs(window.currentPremiseText || 'H is east of R; Y is north of X.', 0.90) + (secondsPerTrial() * 1000) + 1500;
                if (now - lastTick > typical) {
                    console.warn('Watchdog nudge');
                    cancelSpeechImmediately();
                    if (session?.policy === AdvancePolicy.ACTIVE) {
                        window.forceCurrentTrialTimeout?.();
                    } else {
                        Timer.set('dwell-nudge', 50, session.trialToken, session.abort.signal, () => {});
                    }
                    lastTick = now;
                }
            }, 500);
        }

        function onRepeatPressed() {
            if (!session) return;
            const premise = engine.activePremise || engine.currentPremises[Math.max(0, session.trialIndex - 1)];
            if (!premise) return;
            noteExplicitRepeat();
            cancelSpeechImmediately();
            setTimeout(() => {
                if (!session || session.abort.signal.aborted) return;
                SpeechGate.inFlight = false;
                SpeechGate.flightToken = null;
                speakPremiseSafe(session, premise, session.trialToken, session.abort.signal);
            }, 120);
        }

        function shouldAutoStopForOmissions() {
            return session?.policy === AdvancePolicy.ACTIVE;
        }

        document.addEventListener('visibilitychange', () => {
            try {
                window.speechSynthesis?.resume();
            } catch (err) {
                console.warn('speechSynthesis.resume visibility failed', err);
            }
        });
        class InstructionsManager {
            constructor(engine) {
                this.engine = engine;
                this.voice = engine.voice;
                this.sections = TUTORIAL_SECTIONS;
                this.dialog = document.getElementById('dlgInstructions');
                this.openButton = document.getElementById('btnInstructions');
                this.closeButton = document.getElementById('instClose');
                this.nav = document.getElementById('instTabs');
                this.tabButtons = Array.from(this.nav.querySelectorAll('button'));
                this.content = document.getElementById('instContent');
                this.prevButton = document.getElementById('instPrev');
                this.nextButton = document.getElementById('instNext');
                this.readAloudCheckbox = document.getElementById('instReadAloud');
                this.currentIndex = 0;
                this.dialogOpen = false;
                this.previousFocus = null;
                this.visited = new Set();
                this.completed = false;
                this.readAloud = false;
                this.pendingSpeechToken = null;
                this.boundKeydown = (event) => this.handleKeydown(event);
                this.boundFocusIn = (event) => this.enforceFocus(event);
                this.nav.setAttribute('role', 'tablist');
                this.tabButtons.forEach(btn => {
                    btn.setAttribute('role', 'tab');
                    const isActive = this.sections[this.currentIndex] && this.sections[this.currentIndex].id === btn.dataset.tab;
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                this.sandbox = {
                    premise: null,
                    mapping: {},
                    journal: []
                };
                this.sandboxElements = null;
            }

            initialize() {
                this.loadState();
                this.attachEvents();
                this.renderCurrentSection();
                this.updateCompletionState();
            }

            loadState() {
                const storedSection = localStorage.getItem('instSection');
                const storedIndex = this.sections.findIndex(section => section.id === storedSection);
                if (storedIndex >= 0) {
                    this.currentIndex = storedIndex;
                }

                const visitedRaw = localStorage.getItem('instVisited');
                if (visitedRaw) {
                    try {
                        const parsed = JSON.parse(visitedRaw);
                        if (Array.isArray(parsed)) {
                            parsed.forEach(id => this.visited.add(id));
                        }
                    } catch (err) {
                        console.warn('Failed to parse tutorial visited state', err);
                    }
                }

                const completed = localStorage.getItem('instCompleted');
                this.completed = completed === 'true';

                const readAloud = localStorage.getItem('instReadAloud');
                this.readAloud = readAloud === 'true';
                this.readAloudCheckbox.checked = this.readAloud;

                const journalRaw = localStorage.getItem('instPracticeJournal');
                if (journalRaw) {
                    try {
                        const parsed = JSON.parse(journalRaw);
                        if (Array.isArray(parsed)) {
                            this.sandbox.journal = parsed;
                        }
                    } catch (err) {
                        console.warn('Failed to parse sandbox journal', err);
                    }
                }
            }

            attachEvents() {
                this.openButton.addEventListener('click', () => this.openDialog());
                this.closeButton.addEventListener('click', () => this.closeDialog());

                this.tabButtons.forEach((button) => {
                    const sectionId = button.dataset.tab;
                    const index = this.sections.findIndex(section => section.id === sectionId);
                    if (index === -1) return;
                    button.addEventListener('click', () => {
                        this.currentIndex = index;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    });
                });

                this.prevButton.addEventListener('click', () => {
                    if (this.currentIndex > 0) {
                        this.currentIndex -= 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.nextButton.addEventListener('click', () => {
                    if (this.currentIndex < this.sections.length - 1) {
                        this.currentIndex += 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.readAloudCheckbox.addEventListener('change', (event) => {
                    this.readAloud = event.target.checked;
                    localStorage.setItem('instReadAloud', this.readAloud ? 'true' : 'false');
                    if (this.dialogOpen && this.readAloud) {
                        this.queueSpeech(true);
                    } else {
                        this.cancelSpeech();
                    }
                });
            }

            openDialog() {
                if (this.dialogOpen) return;
                this.dialogOpen = true;
                this.previousFocus = document.activeElement;
                this.dialog.hidden = false;
                document.body.classList.add('dialog-open');
                this.content.scrollTop = 0;
                this.markVisited(this.sections[this.currentIndex].id);
                this.focusInitialElement();
                document.addEventListener('keydown', this.boundKeydown, true);
                document.addEventListener('focusin', this.boundFocusIn, true);
                if (this.readAloud) {
                    this.queueSpeech(true);
                }
            }

            closeDialog() {
                if (!this.dialogOpen) return;
                this.dialogOpen = false;
                this.dialog.hidden = true;
                document.body.classList.remove('dialog-open');
                document.removeEventListener('keydown', this.boundKeydown, true);
                document.removeEventListener('focusin', this.boundFocusIn, true);
                this.cancelSpeech();
                if (this.previousFocus && typeof this.previousFocus.focus === 'function') {
                    this.previousFocus.focus();
                } else {
                    this.openButton.focus();
                }
            }

            handleKeydown(event) {
                if (!this.dialogOpen) return;
                if (event.key === 'Escape') {
                    event.preventDefault();
                    this.closeDialog();
                    return;
                }
                if (event.key === 'Tab') {
                    this.trapFocus(event);
                }
            }

            enforceFocus(event) {
                if (!this.dialogOpen) return;
                if (!this.dialog.contains(event.target)) {
                    const focusable = this.getFocusableElements();
                    if (focusable.length > 0) {
                        focusable[0].focus();
                    } else {
                        this.content.focus();
                    }
                }
            }

            trapFocus(event) {
                const focusable = this.getFocusableElements();
                if (focusable.length === 0) {
                    event.preventDefault();
                    this.content.focus();
                    return;
                }
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !this.dialog.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            getFocusableElements() {
                const selectors = ['button', '[href]', 'input', 'select', 'textarea', '[tabindex]:not([tabindex="-1"])'];
                return Array.from(this.dialog.querySelectorAll(selectors.join(',')))
                    .filter(el => !el.hasAttribute('disabled') && el.tabIndex !== -1 && this.dialog.contains(el));
            }

            focusInitialElement() {
                const focusable = this.getFocusableElements();
                if (focusable.length > 0) {
                    focusable[0].focus();
                } else {
                    this.content.focus();
                }
            }

            renderCurrentSection() {
                const section = this.sections[this.currentIndex];
                if (!section) return;
                this.tabButtons.forEach((button) => {
                    const isActive = button.dataset.tab === section.id;
                    button.classList.toggle('active', isActive);
                    if (this.visited.has(button.dataset.tab)) {
                        button.classList.add('visited');
                    }
                    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    button.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                if (typeof section.render === 'function') {
                    this.content.innerHTML = '';
                    section.render(this.content);
                } else {
                    this.content.innerHTML = section.html;
                    if (section.id === 'examples') {
                        renderGuidedExamples();
                    }
                }
                this.content.scrollTop = 0;
                localStorage.setItem('instSection', section.id);
                this.markVisited(section.id);
                this.updateNavButtons();
                if (section.id === 'practice') {
                    this.setupSandboxUI();
                } else {
                    this.sandboxElements = null;
                }
                if (this.dialogOpen && this.readAloud) {
                    this.queueSpeech();
                }
            }

            updateNavButtons() {
                this.prevButton.disabled = this.currentIndex === 0;
                this.nextButton.disabled = this.currentIndex === this.sections.length - 1;
            }

            markVisited(id) {
                if (!this.visited.has(id)) {
                    this.visited.add(id);
                    localStorage.setItem('instVisited', JSON.stringify(Array.from(this.visited)));
                }
                if (this.visited.size === this.sections.length) {
                    this.completed = true;
                    localStorage.setItem('instCompleted', 'true');
                }
                this.updateCompletionState();
            }

            updateCompletionState() {
                this.openButton.classList.toggle('completed', this.completed);
            }

            async queueSpeech(force = false) {
                if (!this.readAloud || !this.dialogOpen) return;
                if (!this.voice || !this.voice.voiceReady) return;
                const section = this.sections[this.currentIndex];
                if (!section || !section.speech) return;
                const token = Symbol('instSpeech');
                this.pendingSpeechToken = token;
                if (force) {
                    await this.voice.cancelAndWait();
                } else {
                    await this.voice.cancelAndWait();
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!this.dialogOpen || !this.readAloud || this.pendingSpeechToken !== token) {
                    return;
                }
                await this.voice.speak(section.speech, this.voice.sessionToken);
            }

            cancelSpeech() {
                this.pendingSpeechToken = null;
                if (this.voice && typeof this.voice.cancelAndWait === 'function') {
                    this.voice.cancelAndWait();
                }
            }

            setupSandboxUI() {
                const panel = document.createElement('div');
                panel.className = 'sandbox-panel';

                const workspaceTitle = document.createElement('h4');
                workspaceTitle.textContent = 'Practice Workspace';
                panel.appendChild(workspaceTitle);

                const controls = document.createElement('div');
                controls.className = 'sandbox-controls';

                const loadBtn = this.createSandboxButton('Load current premise', () => this.loadCurrentPremise());
                const spawnBtn = this.createSandboxButton('Spawn practice premise', () => this.spawnPracticePremise());
                const applyBtn = this.createSandboxButton('Apply Relation Operations', () => this.applySandboxOperations());
                const commitBtn = this.createSandboxButton('Commit to Journal', () => this.commitSandboxJournal());

                controls.append(loadBtn, spawnBtn, applyBtn, commitBtn);
                panel.appendChild(controls);

                const status = document.createElement('div');
                status.className = 'hint';
                panel.appendChild(status);

                const atoms = document.createElement('div');
                atoms.className = 'sandbox-atom-list';
                panel.appendChild(atoms);

                const grid = document.createElement('div');
                grid.className = 'sandbox-letter-grid';
                panel.appendChild(grid);

                const journalTitle = document.createElement('h4');
                journalTitle.textContent = 'Journal';
                panel.appendChild(journalTitle);

                const journal = document.createElement('div');
                journal.className = 'sandbox-journal';
                panel.appendChild(journal);

                this.content.appendChild(panel);

                this.sandboxElements = {
                    status,
                    atoms,
                    grid,
                    journal
                };

                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.renderSandboxJournal();
                this.updateSandboxStatus('Load the latest premise or spawn a fresh training premise to begin.');
            }

            createSandboxButton(label, handler) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'secondary';
                btn.textContent = label;
                btn.addEventListener('click', handler);
                return btn;
            }

            loadCurrentPremise() {
                const current = this.engine.currentPremises && this.engine.currentPremises.length > 0
                    ? this.engine.currentPremises[this.engine.currentPremises.length - 1]
                    : null;
                if (!current) {
                    this.updateSandboxStatus('No live premise available yet. Start a session or spawn practice.');
                    return;
                }
                this.sandbox.premise = {
                    atoms: current.atoms.map(atom => ({ axis: atom.axis, head: atom.head, tail: atom.tail }))
                };
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Loaded the latest live premise into the sandbox.');
            }

            spawnPracticePremise() {
                const practice = this.generatePracticePremise();
                this.sandbox.premise = practice;
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Spawned a fresh training premise.');
            }

            generatePracticePremise() {
                const k = Math.max(2, Math.min(4, this.engine ? this.engine.k : 3));
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const usedPairs = new Set();
                const atoms = [];
                for (let i = 0; i < k; i++) {
                    let head = letters[Math.floor(Math.random() * letters.length)];
                    let tail = letters[Math.floor(Math.random() * letters.length)];
                    let attempts = 0;
                    while ((head === tail || usedPairs.has(`${head}-${tail}`)) && attempts < 40) {
                        head = letters[Math.floor(Math.random() * letters.length)];
                        tail = letters[Math.floor(Math.random() * letters.length)];
                        attempts += 1;
                    }
                    usedPairs.add(`${head}-${tail}`);
                    const axis = MATCH_AXES[Math.floor(Math.random() * MATCH_AXES.length)];
                    atoms.push({ axis, head, tail });
                }
                return { atoms };
            }

            applySandboxOperations() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before applying operations.');
                    return;
                }
                let changed = false;
                const mapping = this.sandbox.mapping;
                this.sandbox.premise.atoms.forEach(atom => {
                    const headKey = atom.head;
                    const tailKey = atom.tail;
                    const headValue = (mapping[headKey] || '').trim();
                    const tailValue = (mapping[tailKey] || '').trim();
                    const transform = SANDBOX_TRANSFORMS[atom.axis];
                    if (!transform) return;
                    if (tailValue && !headValue) {
                        mapping[headKey] = transform.forward(tailValue);
                        changed = true;
                    } else if (headValue && !tailValue) {
                        mapping[tailKey] = transform.reverse(headValue);
                        changed = true;
                    }
                });
                this.renderSandboxInputs();
                this.updateSandboxStatus(changed ? 'Applied relation operations. Tweak any concept as needed.' : 'No changes applied. Anchor at least one letter first.');
            }

            commitSandboxJournal() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before committing to the journal.');
                    return;
                }
                const entries = Object.entries(this.sandbox.mapping)
                    .map(([letter, value]) => [letter, value ? value.trim() : ''])
                    .filter(([, value]) => value.length > 0)
                    .sort((a, b) => a[0].localeCompare(b[0]));
                if (entries.length === 0) {
                    this.updateSandboxStatus('Add at least one mapped concept before committing.');
                    return;
                }
                const record = {
                    timestamp: new Date().toISOString(),
                    premise: this.sandbox.premise.atoms,
                    mapping: entries
                };
                this.sandbox.journal.unshift(record);
                this.sandbox.journal = this.sandbox.journal.slice(0, 20);
                localStorage.setItem('instPracticeJournal', JSON.stringify(this.sandbox.journal));
                this.renderSandboxJournal();
                this.updateSandboxStatus('Mapping committed to journal.');
            }

            renderSandboxPremise() {
                if (!this.sandboxElements) return;
                const atoms = this.sandbox.premise ? this.sandbox.premise.atoms : [];
                if (!atoms || atoms.length === 0) {
                    this.sandboxElements.atoms.textContent = 'No practice premise loaded yet.';
                } else {
                    this.sandboxElements.atoms.textContent = atoms
                        .map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`)
                        .join('; ');
                }
            }

            renderSandboxInputs() {
                if (!this.sandboxElements) return;
                const grid = this.sandboxElements.grid;
                grid.innerHTML = '';
                if (!this.sandbox.premise) return;
                const letters = new Set();
                this.sandbox.premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                Array.from(letters).sort().forEach(letter => {
                    const cell = document.createElement('div');
                    cell.className = 'sandbox-letter';
                    const label = document.createElement('label');
                    label.textContent = `${letter} concept`;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = this.sandbox.mapping[letter] || '';
                    input.addEventListener('input', (event) => {
                        this.sandbox.mapping[letter] = event.target.value;
                    });
                    cell.append(label, input);
                    grid.appendChild(cell);
                });
            }

            renderSandboxJournal() {
                if (!this.sandboxElements) return;
                const journal = this.sandboxElements.journal;
                journal.innerHTML = '';
                if (this.sandbox.journal.length === 0) {
                    const empty = document.createElement('p');
                    empty.className = 'hint';
                    empty.textContent = 'Your journal entries will appear here.';
                    journal.appendChild(empty);
                    return;
                }
                this.sandbox.journal.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'sandbox-journal-entry';
                    const timestamp = document.createElement('div');
                    timestamp.innerHTML = `<strong>${new Date(entry.timestamp).toLocaleString()}</strong>`;
                    const premise = document.createElement('div');
                    premise.textContent = `Premise: ${entry.premise.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ')}`;
                    const mapping = document.createElement('div');
                    mapping.innerHTML = entry.mapping.map(([letter, value]) => `<code>${letter}</code>: ${value}`).join('; ');
                    item.append(timestamp, premise, mapping);
                    journal.appendChild(item);
                });
            }

            updateSandboxStatus(message) {
                if (!this.sandboxElements) return;
                this.sandboxElements.status.textContent = message;
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const dummyEngine = new GameEngine();
                await dummyEngine.voice.initialize();
                const dummySession = {
                    ...newSession(dummyEngine),
                    abort: new AbortController(),
                    trialToken: 1
                };
                session = dummySession;
                const promise = collectResponseSafe(0.05, dummySession.trialToken, dummySession.abort.signal);
                dummySession.abort.abort();
                const result = await promise;
                session = null;
                return {
                    test: 'Input gating',
                    passed: result.type === 'timeout',
                    details: 'Abort resolves response promise as timeout'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }
        }

        const engine = new GameEngine();
        const instructions = new InstructionsManager(engine);
        instructions.initialize();
        engine.initialize().then(() => {
            instructions.updateCompletionState();
            if (instructions.dialogOpen && instructions.readAloud) {
                instructions.queueSpeech(true);
            }
        });
    </script>
</body>
</html>
